\documentclass[12pt,twoside,openright,a4paper]{article}
%\documentclass[12pt,twoside,openright,usletter]{article}
% !TeX spellcheck = en_US
%\documentclass[11pt]{article}
% UK date format in bibliography:
\usepackage[british]{babel}
\usepackage[inner=25mm,outer=25mm,top=20mm,bottom=20mm]{geometry}

%\usepackage[UKenglish]{isodate}%UK date endian
\usepackage[headings]{fullpage}
\usepackage[hidelinks]{hyperref}

% Bibliography:
\usepackage[utf8]{inputenc}
\usepackage{csquotes,xpatch}% recommended
% list up to 99 names instead of the default 3
\usepackage[backend=biber,bibencoding=utf8,style=numeric,maxnames=99,backref=false,sortcites,datamodel=thesis]{biblatex}
\addbibresource{cheri.bib}
\AtEveryBibitem{%
% Don't print ISBN,issn, or URL dates
\clearfield{issn}%
\clearfield{isbn}%
\clearfield{urldate}%
\clearfield{urlyear}%
}

\usepackage{bytefield}
\usepackage{color}
\usepackage[scaled=0.8]{DejaVuSansMono}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{mdframed} % To avoid linebreaks in lstlistings
\lstnewenvironment{clisting}[1][]{\endgraf\noindent\minipage{\linewidth}\lstset{language={C},breaklines=true,frame=L,#1}}{\endminipage\endgraf}
\lstnewenvironment{compilerwarning}[1][]{\endgraf\noindent\minipage{\linewidth}\lstset{language={},breaklines=true,basicstyle=\scriptsize\ttfamily\bfseries,frame=L,#1}}{\endminipage\endgraf}

\usepackage{subcaption}
\usepackage{times}
\usepackage{url}
\usepackage[svgnames]{xcolor}
\definecolor{lightgray}{gray}{0.8}
\usepackage{xspace}
\usepackage{xfrac}

\usepackage[nameinlink,noabbrev,capitalise]{cleveref}

% drawing over lstlistings (code stolen from nwf)
\usepackage{tikz}
   \usetikzlibrary{decorations.pathreplacing}
   \usetikzlibrary{fit}
   \usetikzlibrary{tikzmark}
   \usetikzlibrary{calc}
   \usetikzlibrary{patterns}
\newcommand*{\vcpgfmark}[1]{\ensuremath{\vcenter{\hbox{\pgfmark{#1}}}}}
% GBP symbol should be safe since it's easy to enter (at least on a UK keyboard) and won't be in any valid lstlistings
\lstset{escapechar=Â£} % Note: ensure this doesn't occur in any of the code
\newcommand{\TikzListingHighlight}[3][]{\tikz[overlay,remember picture]{\draw[\ifstrempty{#1}{yellow}{#1}, line width=10pt,opacity=0.3](#2) -- (#3);}}
\newcommand*{\TikzListingHighlightStartEnd}[2][]{\tikz[overlay,remember picture]{\draw[\ifstrempty{#1}{yellow}{#1}, line width=10pt,opacity=0.3](pic cs:Start#2) -- (pic cs:End#2);}}


\renewcommand{\UrlFont}{\ttfamily\small}

\newcommand{\baselineboxformatting}[1]{%
  % Measure size of contents
  \sbox0{#1}%
  % Use the difference between the contents' height and the bitbox's height,
  % clamped to [-.44\baselineskip, 0], as our minimum depth.
  \setlength{\skip0}{\ht0 - \height}%
  \ifdim\skip0>0pt%
    \setlength{\skip0}{0}%
  \else%
    \ifdim\skip0<-.44\baselineskip%
      \setlength{\skip0}{-.44\baselineskip}%
    \fi%
  \fi%
  \centering\rule[\skip0]{0pt}{\height}#1}
\bytefieldsetup{boxformatting=\baselineboxformatting}

\lstset{basicstyle=\footnotesize\ttfamily}
%\newcommand{\ccode}[1]{\lstinline[language={C}]{#1}}
%\newcommand{\cxxcode}[1]{\lstinline[language={C++}]{#1}}
\newcommand{\ccode}[1]{{\small\ttfamily{#1}}}
\newcommand{\cxxcode}[1]{{\ccode{#1}}}
\newcommand{\cconst}[1]{{\ccode{#1}}}
\newcommand{\cfunc}[1]{{\ccode{#1()}}}
\newcommand{\cvar}[1]{{\ccode{#1}}}
\newcommand{\pathname}[1]{{\ccode{#1}}}
\newcommand{\commandline}[1]{{\ccode{#1}}}

\newcommand{\ptrdifft}{{\ccode{ptrdiff\_t}}\xspace}
\newcommand{\maxalignt}{{\ccode{max\_align\_t}}\xspace}
\newcommand{\sizet}{{\ccode{size\_t}}\xspace}
\newcommand{\ssizet}{{\ccode{ssize\_t}}\xspace}
\newcommand{\ptraddrt}{{\ccode{ptraddr\_t}}\xspace}
\newcommand{\cuintptrt}{{\ccode{uintptr\_t}}\xspace}
\newcommand{\cintptrt}{{\ccode{intptr\_t}}\xspace}
\newcommand{\ccharstar}{{\ccode{char *}}\xspace}
\newcommand{\cvoidstar}{{\ccode{void *}}\xspace}
\newcommand{\clongt}{{\ccode{long}}\xspace}
\newcommand{\cintt}{{\ccode{int}}\xspace}
\newcommand{\cintttt}{{\ccode{int32\_t}}\xspace}
\newcommand{\cintsft}{{\ccode{int64\_t}}\xspace}
\newcommand{\cintcapt}{{\ccode{intcap\_t}}\xspace}

\newcommand{\uucap}{{\ccode{\_\_capability}}\xspace}

\newcommand{\SIGPROT}{{\ccode{SIGPROT}}\xspace}

\newcommand{\futurevariant}[1]{{\color{purple} #1}}
\newcommand{\morellovariant}[1]{{\color{red} #1}}

\newcommand{\note}[2]{{\color{blue}[ Note: #1 - #2]}}
\usepackage{xstring}
\IfSubStr*{\jobname}{final}{
  \renewcommand{\note}[2]{\relax\ifhmode\unskip\fi}
}{
  % show comments by default
}

\newcommand{\arnote}[1]{\note{#1}{Alex R.}}
\newcommand{\bdnote}[1]{\note{#1}{Brooks D.}}
\newcommand{\rwnote}[1]{\note{#1}{Robert W.}}
\newcommand{\amnote}[1]{\note{#1}{Alfredo M.}}
\newcommand{\psnote}[1]{\note{#1}{Peter S.}}
\newcommand{\pgnnote}[1]{\note{#1}{Peter N.}}
\newcommand{\jrtcnote}[1]{\note{#1}{Jess C.}}
\newcommand{\hmnote}[1]{\note{#1}{Hesham A.}}
\newcommand{\nwfnote}[1]{\note{#1}{nwf}}
\newcommand{\dcnote}[1]{\note{#1}{David}}

% typeset C++ sensibly
% NB: \nolinebreak was only made robust upstream on 2019-08-20
\usepackage{relsize}
\newcommand*{\cpp}{\texorpdfstring{C\textsmaller[2]{\protect\nolinebreak[4]\hspace{-.05em}\raisebox{.45ex}{\textbf{++}}}}{C++}}
\newcommand*{\COrCpp}{C/\cpp{}}
\newcommand*{\purecapCOrCpp}{CHERI \COrCpp{}}
\newcommand*{\CHERIhybridCOrCpp}{CHERI Hybrid \COrCpp{}}
\newcommand*{\hybridCOrCpp}{Hybrid \COrCpp{}}

\hyphenation{Free-BSD}
\hyphenation{Free-RTOS}
\hyphenation{Cheri-BSD}
\hyphenation{Cheri-Free-RTOS}
\hyphenation{Cheri-ABI}
\hyphenation{Web-Kit}
\hyphenation{Postgre-SQL}

\title{Review Draft: \\
  \CHERIhybridCOrCpp{} Programming Guide \\
  (DRAFT)}
\author{Robert~N.~M.~Watson$^*$,
    Alexander~Richardson$^*$,
    Jessica~Clarke$^*$,
    Brooks Davis$^\dagger$, \\
    John Baldwin$^\ddagger$,
    David Chisnall$^\S$,
    Nathaniel Filardo$^\S$,
    Simon W. Moore$^*$, \\
    Edward Napierala$^*$,
    Peter Sewell$^*$,
    Peter~G.~Neumann$^\dagger$
  \\
    \textbf{(others to be added)}
  \\
  \\
  $^*$University of Cambridge, $^\dagger$SRI International, \\
  $^\ddagger$Ararat River Consulting, LLC and $^\S$Microsoft Research}
%
%Alexander Richardson$^*$,
%  Brooks Davis$^\dagger$, \\
%  John Baldwin$^\ddagger$, David Chisnall$^\S$, Jessica Clarke$^*$,
%  Nathaniel Filardo$^*$, \\
%  Simon W. Moore$^*$,  Edward Napierala$^*$, Peter Sewell$^*$, and \\
%  Peter G. Neumann$^\dagger$ \\
%  \\

\begin{document}
\sloppy

%% CL tech-report format provides its own cover page.  Comment for final
%% version.
\maketitle

%% CL tech-report format requires page numbering to start at 3.  Uncomment for
%% final version.
%\setcounter{page}{3}
%%

%
% Keep Abstract in sync with the Introduction.
%
\newcommand{\abstracttext}{

This document is an introduction to the \CHERIhybridCOrCpp{} programming
languages.
\psnote{pluralised languages here, as otherwise it jars, leaving the occurrences below unchanged - the slash makes the latter sort-of-ok IMO, abeit debatable}
\hybridCOrCpp{} allows the selective use of CHERI capabilities from within an
otherwise unmodified, and Application Binary Interface (ABI)-compatible,
C/\cpp{}-language code base.
Its aim is to allow management of, and interoperation with, capability-enabled
code while using an integer rather than capability pointer implementation
internally.
Unlike pure-capability \purecapCOrCpp{}, \hybridCOrCpp{} defaults to an
integer implementation for pointers except where specifically annotated in the
program source code.
Due to the requirement for ABI compatibility, implied pointers within the
language runtime itself are also primarily implemented as integers rather than
capabilities.

\hybridCOrCpp{} primarily sees use in specialized low-level systems code that,
for compatibility or performance reasons, must use non-capability pointers, or
on the boundaries between pure-capability and conventional generated code.
Current use cases includes boot loaders, operating-system kernels, and
Inter-Process Communication (IPC) runtimes.
Potential future use cases include programs that have been formally verified
(which do not require dynamic memory safety) and applications with high static
or dynamic pointer density such as language runtimes (leading to unaffordable
memory-allocation footprints or cache utilization and energy use).

\dcnote{I don't find the language runtimes argument particularly compelling.
I'd expect things like Java / JavaScript to carry an explicit heap capability
in managed code (which may be DDC), but use the pure-cap ABI in any supporting
C/C++ code so that they support memory safety everywhere.  There's no problem
in the pure-cap ABI with having a 4GiB GC'd heap capability and using 32-bit
integer offsets within that as inter-object pointers on that heap.  I see the
two main uses for the hybrid ABI: (1) Providing some targeted hardening for
high-value targets, for example using capabilities for all objects parsed from
an untrusted source and (2) providing wrappers around compartmentalised legacy
libraries for use in pure-cap programs.  In use (1), you would typically want
an allocator that returns non-DDC memory to the program.}

\rwnote{I agree that I consider this a less compelling use case than a
  pure-capability runtime with integer heap offsets for per-language heaps.
  But there are other CHERI consumers who consider it highly desirable.}

\nwfnote{Do you want to call out partially adapted compartmentalized programs
(possibly inclusive of programs with their own runtime systems; one could
imagine enriching JS to have a ForeignCapability type, e.g.) as another
possible example where being able to exchange capabilities might be useful
despite possibly having a non-NULL DDC?}

%Hybrid code is used in the CheriBSD kernel, and in the userspace run-time
%environment for hybrid processes to enable communication with pure-capability
%processes via co-process IPC.

%Because the benefits of referential, spatial, and temporal memory safety are
%unavailable to both the program and language runtime, care should be utilized,
%and \hybridCOrCpp{} should be used only where strictly necessary.
Because the benefits of CHERI referential, spatial, and temporal memory safety are
unavailable to both the program and language runtime in \hybridCOrCpp{},
its use requires care and should be avoided where not strictly necessary.

}

\newcommand{\reviewwarning}{
\textbf{
As \hybridCOrCpp{} remains an area of active research and development, this
report is a request for review and comments rather than a specification.
}
\rwnote{This last sentence will go away in a final version.}
}

\begin{abstract}
\abstracttext

\reviewwarning
\end{abstract}

\newpage
\setcounter{tocdepth}{2}
\tableofcontents

\newpage

\section{Introduction}

%
% Keep Abstract in sync with the Introduction.
%
\abstracttext

This is a companion to the \textit{\purecapCOrCpp{} Programming
Guide}~\cite{UCAM-CL-TR-947}, and refers to that report rather than
replicating its contents.
Readers will benefit from having read that document prior to this one, as
many behaviors in \hybridCOrCpp{} are based on those in \purecapCOrCpp{}, or
will be contrasted with it in this guide.
The \textit{Introduction to CHERI} technical
report~\cite{UCAM-CL-TR-941} also provides background material for this
guide.

\subsection{Document structure}

This report describes:

\begin{itemize}
\item The objectives and potential use cases for \CHERIhybridCOrCpp{};
\item How \hybridCOrCpp{} interacts with explicit pointers in program source
  code, as well as implied pointers in the language runtime;
\item The impact of \hybridCOrCpp{} on C-language types, casts and the address-of operator
  (\ccode{\&});
\item A number of inherent and practical implications to \hybridCOrCpp{}; and
\item Further reading relating to CHERI and \COrCpp{} on CHERI.
\end{itemize}

\subsection{Status of this document}

This document is a request for comments and feedback, and not a stable
specification.
This document currently describes three variants of \hybridCOrCpp{}:

\begin{enumerate}
\item \hybridCOrCpp{} as implemented in the CHERI Clang/LLVM implementation on
  CHERI-MIPS and CHERI-RISC-V.

  Unless otherwise indicated, all statements refer to this model.

\item \hybridCOrCpp{} as implemented in the CHERI Clang/LLVM implementation on
  Morello (which differs in small but important ways).

  Key differences are in \morellovariant{red text}.

\item Our current thinking on next directions for \hybridCOrCpp{}.

  Key differences are in \futurevariant{purple text}.
\end{enumerate}

\noindent
We have attempted to clearly comment on these behavioral divergences where
required.
It is our aim to achieve convergence of these approaches so that a single
\CHERIhybridCOrCpp{} can be used across all architectures, and best addresses
all use cases.
Feedback on this draft may be submitted via pull requests or the issue tracker
on our GitHub repository for the report:

\smallskip

\url{https://github.com/CTSRD-CHERI/cheri-hybrid-c-guide}

\section{Objective and use cases for \hybridCOrCpp{}}

\psnote{somewhere early on, maybe here, this document should be saying what code has been ported to (or implemented from scratch) in Hybrid}

The aim of \hybridCOrCpp{} is to allow programs to be written using
conventional integer pointers throughout their implementations, and yet also
to interact with capabilities via modest C-language extensions causing
specifically annotated pointers to be implemented using capabilities.
This is in contrast to \purecapCOrCpp{}, which implements all pointers as
capabilities by default, and whose aim is strong referential, spatial, and
temporal memory protection for C/\cpp{}.
\psnote{including ``temporal'' there, unqualified, is going to be confusing.  Suggest splitting the sentence up and describing more explicitly what the current state and plausible options are w.r.t. temporal}
While \hybridCOrCpp{} is unable to provide strong referential, spatial, or
temporal safety in most use cases, it allows conventional
integer-pointer-based code to interact usefully with capabilities in a number
of specific use cases.
\psnote{that seems to underplay what one can get from hybrid -- surely one can say something about ``specific protections'' or ``protection in specific ways'' or something?}

\subsection{Hybrid CheriBSD kernel}

\psnote{I know this isn't really supposed to be standalone, but best say \emph{something} about what CheriBSD is, rather than introducing it en passant}

CheriBSD implements two kernel variants: a \hybridCOrCpp{} compilation, and a
\purecapCOrCpp{} variant.
The former, \hybridCOrCpp{} compilation, aims to support a CHERI-enabled userspace
without substantive changes to kernel-internal protection.
The latter additionally aims to use CHERI memory protection within the
kernel.
\psnote{say explicitly that we don't discuss the latter further here?  Otherwise it's confusing to set up the opposition but then only talk about the former below}
Both kernel variants support hybrid and pure-capability (CheriABI) userspace
process environments.

The \hybridCOrCpp{}-compiled CheriBSD kernel is almost entirely implemented
in conventional \COrCpp{} using integer pointers, except for its handling of
pointers to userspace (e.g.  system-call arguments) and capability state,
which are manually annotated.
Capability pointers are used in this version of the kernel for three reasons:

\begin{enumerate}
\item to manage the dynamic state of capability-enabled kernel and user
  threads, as part of context management and exception handling;

\item in the implementation of tag-enabled virtual-memory abstractions, such
  as copy-on-write propagating tag bits; and

\item to handle pointer-type userspace system-call arguments as capabilities
  rather than integer pointers, both to enable capability-based behaviors
  (such as having opaque pointer types used in POSIX asynchronous I/O be able
  to hold capabilities), and to prevent confused deputy attacks (such as might
  occur if an omnipotent kernel ignored userspace-originated bounds on stack
  or heap allocations).
\end{enumerate}

In order to unify system-call handling, user pointers originating in hybrid
ABI processes are converted into capability pointers at the system-call
boundary%
\footnote{System-call arguments may point to object containing pointers
which the kernel must also translate.
Such translation may occur at the syscall-boundry (e.g. the \ccode{struct iovec}
in \ccode{readv} or deep within the kernel (e.g. a driver-specific \ccode{ioctl}
struct.)}
%
This leads to coarse-grained bounds, but, for example, permits user pointers to
be used only in accessing userspace memory.
For pure-capability (CheriABI) processes, user pointer types originate as
capabilities, and are simply propagated as necessary.
This approach is moderately disruptive of the kernel source code: While there
are few structural changes, user-originated pointers are manually annotated
with \uucap{} throughout.

\subsection{The CheriBSD hybrid process environment}

\psnote{Say what this is?}

In the usermode portion of the CheriBSD hybrid ABI process environment,
\psnote{as supported by either the hybrid or pure variants??}
some
system libraries are extended with modest capability annotations to support
capability use.
For example, \ccode{memcpy()} and \ccode{sort()} must propagate tags rather
than perform byte-wise copies, in order to preserve pointers embedded in data
structures across memory copies.
\psnote{Apart from that??}
\psnote{[limited/weak] ?}
In general, support for capabilities is weak within the runtime: we have not
updated \ccode{malloc()} to provide a \ccode{malloc\_c()} variant returning
capabilities, implementing suitable capability alignment, or implementing
temporal memory safety.
\psnote{hard to parse the latter parts of the preceding sentence}
\dcnote{We're also missing a \ccode{mmap} variant for allocating memory outside DDC}
System calls are also not generally extended to support capability arguments
or return values, limiting the useful origins for capabilities other than as
derived from the Default Data Capability (DDC) or Program Counter Capability
(PCC).

\subsection{Co-process IPC libraries in hybrid processes}

\psnote{be clear that this is quite separate to the CheriBSD world??}

We have been developing a CHERI-based compartmentalization model called
\textit{co-located processes} (or \textit{co-processes} for short).
In this model, a set of UNIX processes are colocated within a single shared
virtual address space, but kept separate by virtue of CHERI capabilities:
processes only ever receive capabilities to their own individual mappings.

Co-process Inter-Process Communication (IPC) relies on bridging those
processes by allowing a limited set of capabilities to be shared between those
processes.
In this approach, hybrid capability-extended IPC libraries would have access
to the memory of remote processes using CHERI capabilities, but the majority
of code in a hybrid process would not have that direct access.
Depending on performance and compatibility objectives, knowledge of
co-processes could be restricted to low-level IPC libraries, or be propagated
higher in the IPC stack, reducing the need for memory copying.

This is an area where our research is ongoing, but access to high-performance
CHERI IPC with only limited recompilation and extension to existing software
packages is a potentially promising area.

\subsection{Hybrid language runtimes}

Managed language runtimes are a point of particular performance concern with
CHERI, as they often have a high density of pointers in their dynamic memory
access patterns.
This makes them potentially more sensitive to CHERI's pointer-size growth in
pure-capability compilation.
On the other hand, CHERI capabilities offer the opportunity to improve
robustness and performance by allowing selective use of capabilities to
protect key types and provide hardware assistance for bounds checking.
On the whole, our recommendation has been to consider compiling language
runtimes as pure-capability code making selective use of integer pointers
(e.g., into language-specific heaps reached via capabilities), but
another approach would be to compile them as hybrid code making selective use
of capabilities -- e.g., when accessing bounded arrays in the heap.
\dcnote{It feels quite dangerous to have a single sentence about the
recommended way of doing things and a long document about the not-recommended
way.}

\section{Pointer implementation}

\psnote{In hybrid CHERI C/C++...}

Pointers may be implemented using two underlying architectural types:

\begin{description}
\item[Integer pointers] are pointers implemented as integer addresses.
  Storage size and alignment will be the architectural address size (e.g.,
  64 bits on a 64-bit architecture in a 64-bit process environment).

  Generated code will utilize integer load and store instructions to access
  variables of these types, and dereference them using integer-relative
  instructions.

  Explicit pointers will be of this type by default.
  Implied pointers will be of this type if required by the existing ABI.

\item[Capability pointers] are pointers implemented using capabilities.
  Storage size and alignment will be the architectural capability size (e.g.,
  128 bits on a 64-bit architecture in a 64-bit process environment\psnote{, with the tag bit for eachcapability-sized-and-aligned unit of memory maintained by the hardware in non-addressable memory}).

  Generated code will utilize capability load and store instructions to access
  variables of these types, and dereference them using capability-relative
  instructions.

  Explicit pointers will only be of this type if specifically annotated in the
  program source.
  Implied pointers may be of this type if it does not harm the ABI; some
  implied pointers may be replicated in order to allow both types to be used
  (e.g., by providing a GOT and a captable).
\end{description}

In the following sections, we consider the implementation of pointers in
C/\cpp{} source code and also the language runtime.

\subsection{Pointers in source code, code generation, and the runtime}

\dcnote{This definition would benefit from being much earlier.  The doc
currently talks about implied pointers a lot before it ever defines them and
the definition is obvious only to someone who has spent a nontrivial amount of
time hacking on a C/C++ runtime.}
We are concerned with pointers arising from two parts of the C implementation:

\begin{description}
\item[Explicit pointers] are pointers visible in the program source.
  These include declared pointers taken to local, global, or thread-local
  variables, to functions, or pointers to returned heap allocations.
  In \hybridCOrCpp{}, these pointers will be implemented using capabilities
  only if specifically annotated.

\item[Implied pointers] are those used by the language runtime and generated
  code to manage the language implementation itself.
  This includes the stack pointer, program counter and return addresses, PLT
  entries, vtable pointers, and GOT/captable pointers.
  \psnote{wonder whether it'd be useful in this document to briefly explain what each of these latter three are for, to make it useful for C/C++ programmers and semanticists who aren't familiar with these internals?}
  \psnote{actually, maybe it's worth (time permitting) explaining all these, including side-by-side how they work in vanilla, pure-cap, and hybrid?}
  In \hybridCOrCpp{}, these pointers will be implemented using integers,
  although in some cases
\psnote{probably we should be explicit here about which and why, not just ``eg of the GOT''}
  underlying data structures will be replicated to
  provide capability versions of them -- e.g., of the GOT.
\end{description}

\subsection{Explicit pointers}

Explicit pointers can be implemented as capability pointers in several ways:

\begin{description}
\item[Pointers qualified with \uucap{}]
  To implement an explicit pointer as a capability in \hybridCOrCpp{}, the
  qualifier \uucap{} is used on a pointer type.
  For example, \ccode{char * \_\_capability c} declares a capability pointer
  to a \ccode{char}.
  Unqualified explicit pointers will be implemented as integer pointers.


\psnote{The following two items seem to be a radical shift of focus, from what hybrid currently is to (free-wheeling or prototyped?  unclear) speculation about what one could do instead/aswell.  Suggest either skipping or very clearly labelling with their actual status}
  
\item[Other pointers that have no ABI impact]
  \futurevariant{There are opportunities to compile code using capability
  pointers, where using a different underlying architectural type has no
  impact on the ABI exposed (or potentially exposed) to other code.
  For example, unescaped pointers to local variables may be suitable for
  capability-pointer compilation.
  Other constraints may exist, such as the non-embedding of the pointer's size
  in escaped values.
  Further research is required to evaluate the viability and usefulness of
  this potential approach.}
  \dcnote{There's also research needed on the value of this.  The set of things
  described above looks similar to the set that can be statically
        verified as safe and so does not benefit from capabilities.  This
        becomes a lot more interesting in the context of whole-program (or
        whole-library) analysis, where the complexity of verifying the safety
        properties grows much faster than escape analysis.}

\item[Other pointers that have a policy-constrained ABI impact]
  \futurevariant{There is also the opportunity to have a policy-determined
  impact on ABI, in which an explicit policy might allow compilation of
  larger portions of code in a manner that more substantively impacts ABI.
  Such policies might explicitly identify function types and data structures
  (e.g., public APIs) with public ABI guarantees while permitting substantial
  variation in other compiled code (e.g., private APIs).
  Further research is required to evaluate the viability and usefulness of
  this potential approach.}
\end{description}

\rwnote{Do we want a new item, ``Implied pointers that have a limited impact
  on ABI''?  E.g., to capture the CRA case?}

\rwnote{Have we gotten too researchy here, and we should just stick to the
  simple story that only those tagged with \uucap{} matter.
  I seem to recall that we also have a pragma for managing the default
  interpretation to be used in header files shared between interpretations...}

\subsection{Implied pointers}

We consider three cases:

\begin{description}
\item[Implied pointers critical to the ABI]
  Wherever the ABI dictates that implied pointers must be integer pointers,
  that will be maintained by \hybridCOrCpp{} code generation and in the
  language runtime.
  For example, the hybrid ABI requires that the stack pointer be an integer
  pointer.
  \dcnote{This isn't clear to me as a general point.  An ISA that had an
    architectural stack pointer could have a stack capability and define the
    legacy ops that write an integer to the stack pointer to set the address.
    We couldn't do that on MIPS because the stack pointer is non-architectural
    but it would be possible on ARM.}

\item[Implied pointers invisible to the ABI]
  In some cases, implied pointers may be implemented as capability pointers
  without impacting the ABI.

\psnote{again flag more clearly that this is speculative?  The blue colour alone isn't doing it for me}
  
  \futurevariant{For example, hybrid code could use a capability return address
  rather than an integer return address to provide pointer provenance validity
  for the return address, even if not tight bounds, as the return address is
  not part of the ABI to other functions.}

  \jrtcnote{\cfunc{\_\_builtin\_return\_address} does leak these implied
  pointers to some code, and it has implications for things like libunwind, so
  it does affect the ABI. Also the kernel needs to know to put a capability in
  CRA in order for signal handlers to be able to return to \cfunc{sigcode}.
  There's a lot of subtlety here that needs to be captured.}

  \rwnote{I'd been pondering whether the ABI might allow us to use a return
  capability, but in which unwind/etc only looked at the lower 64 bits...  And
  I suppose the builtin could be polymorphic.  But signals are indeed a messy
  issue.
  Is there a better example we could give?}

\item[Implied pointers that can be replicated as integer and capability
  pointers]
  In other cases, implied pointers may be replicated, with a full set of
  integer pointer variants provided for the existing ABI, but additional
  capability pointer variants provided for hybrid code.

  \futurevariant{For example, a separate captable could be provided,
  replicating the set of entries in the existing GOT, to allow capability
  pointers taken to global variables to have desired bounds and permissions.}

  \morellovariant{In the Morello ABI, capability pointers taken to globals
  pick up bounds and other metadata from constant pools of capabilities,
  effectively small per-function captables manually created by the compiler.}

  \psnote{really the first Morell-specific thing?}
  \psnote{the document has never (as far as I noticed) actually explained what a captable \emph{is}. probably that should have been much earlier}

\end{description}

\section{\hybridCOrCpp{}}

\psnote{wasn't the preceding section also all about \hybridCOrCpp{}?}

\psnote{somewhere this document should explain the (library or built-in) operations that one can do in hybrid on capabilities, what arithmetic one can do on them, what comparison does, etc., including concrete syntax (either general or by example)}

The C and \cpp{} languages are generally
unchanged
\psnote{``unperturbed'' has an unfortunate anthropomorphic misreading...}
by the introduction of
\hybridCOrCpp{} support, except where specifically impacted by the use or
implementation of the capability pointer type.
Capability pointers will generally follow the rules, alignment requirements,
integer conversions, provenance, and so on laid out in the \textit{CHERI C/C++
Programming Guide}~\cite{UCAM-CL-TR-947}.
However, substantially different choices are made regarding integer types,
integer-pointer casts, and the address-taken operator, as described in this section.

\subsection{C-language types}

In \hybridCOrCpp{}, all existing language types retain their current uses in
order to maximize compatibility, including \cintptrt, \cuintptrt, and
\maxalignt.
This is inconvenient with respect to capability pointer types, which cannot
be stored (without a downcast to an integer pointer type, losing capability
metadata) in \cintptrt.
A new type, \cintcapt, has been introduced, which is able to hold capability
pointer types -- but will be used only by source code that is capability
aware.
\dcnote{Signed and unsigned variants (uintcap\_t)}

\subsection{Casts from integer to capability pointers}

Casts from integer pointers to capability pointers will silently \rwnote{is
this still true?} generate a capability pointer value derived from the
Default Data Capability (DDC).
As a result, they will generally have highly permissive bounds and
permissions, which should be refined for the capability to offer spatial,
and not just referential, protection.
\psnote{I'm guessing the reader will have no idea what ``referential protection'' means...}

For example, if an integer pointer to a heap allocation is to be exposed to
co-process IPC using a capability, the code performing a cast to a capability
pointer will typically also need to set bounds and permissions suitably.
This use case may also require stronger alignment for the heap allocation than
the existing heap allocator provides, as the allocator will be unaware of
capability bounds precision requirements.
\psnote{give example code showing how this setting of bounds and permissions can be done?}

Because of these risks, CHERI Clang/LLVM will always generate a warning in
the absence of use of the new \ccode{\_\_cheri\_addr} qualifier on the target
type of a cast.
\bdnote{I think this is supposed to be \ccode{\_\_cheri\_tocap}. \ccode{\_\_cheri\_addr} is for capability to non-pointer integrer cases.}

\psnote{introducing \ccode{\_\_cheri\_addr} in passing -- better to be more explicit?}

\rwnote{Give examples of warnings?}

\nwfnote{Recommend \ccode{cheri\_address\_set}?}

\bdnote{We rarely use \_\_cheri\_tocap and instead use macros like \ccode{\_\_USER\_CAP} that perform some validation.  In the case of \ccode{\_\_USER\_CAP} we have a \ccode{\_\_USER\_CFROMPTR} that derives
from the process's DDC and (critically) ensures that sentinal values near (signed) zero are NULL-derived. We probably need to mention this here
or above when we talk about syscall arguments.}

\subsection{Casts from capability to integer pointers}

\psnote{terminology: it's pretty easy to misread ``integer pointer'' as ``pointer to integer'', as that's normal C usage.  Maybe we can find a different term?  ``machine-word pointer'' ??}

Casts from capability pointers to integer pointers will take on a value that
is the integer difference between the address of the capability pointer and
the address of DDC.
These casts likewise discard capability metadata, preventing not only spatial
protection, but also referential protection.

Because of these risks, CHERI Clang/LLVM will always generate an error in
the absence of use of the new \ccode{\_\_cheri\_fromcap} qualifier on the
target type of a cast.

\rwnote{Say something about the associated built-ins?}

\rwnote{Give examples of warnings?}

\dcnote{We used to have instructions for this.  The goal for systems without
that was cap -> int pointer casts would do a CTestSubset, CSub, CCMOV sequence,
so casting from a not-in-DDC cap to an integer pointer would give either a
valid pointer or null.  The programmer invariant is that either the resulting
pointer can be used to access the entire object, or it is a detectable null.
The LLVM IR language reference now include this guarantee for address space
casts.}

\bdnote{In the CheriBSD kernel \ccode{\_\_cheri\_fromcap} is commonly used
for kernel-addresses that happen to be stored in capabilities,
but probably should be replaced by a macro that ensures that this is true
on systems where DDC includes userspace addresses (all of them today).}

\subsection{\& operator}

The \ccode{\&} operator takes the address of a C or \cpp{} variable, and
returns a pointer of a corresponding type.
We consider three approaches:

\begin{description}
\item[Integer pointer interpretation] is the approach taken by CHERI
  Clang/LLVM.
  In this approach, \ccode{\&} returns an integer pointer type, the default
  pointer type in \hybridCOrCpp{}.
  If then assigned to a capability pointer, the resulting bounds and
  permissions are derived from the Default Data Capability (DDC).

\nwfnote{Does that mean that I can't write something like...  \ccode{struct \{
int x; int y; \} * \_\_capability sp; int * \_\_capability xp = \&sp->x;} and
have it work unless \ccode{sp} is a subset of DDC?  I'd sort of expect \& to be
polymorphic in its argument, even if it isn't polymorphic in its return type as
given next.}
\bdnote{\&<something of capability type> remains a capability. This requires clarification.}

\item[Polymorphic \ccode{\&}] \morellovariant{is the approach taken by Morello
  Clang/LLVM.
  In this approach, \ccode{\&} is polymorphic: if assigned to a capability
  pointer, the resulting bounds and permissions are those of the underlying
  type.}
  
  \rwnote{Or are they of the underlying storage?}
\psnote{uneasy with the idea that ``the underlying type'' has unambiguous bounds and permissions... esp. given C's handling of arrays.  Spell out what this means?}
  
  \dcnote{Is this equivalent to making it return a capability and silencing
    warnings if you cast that value to an integer pointer without storing it?}

\item[Qualified \ccode{\&}]
  \futurevariant{This approach would qualify or modify the \ccode{\&} operator
  itself, perhaps in the form \ccode{\_\_capability \&}.
  This approach would avoid polymorphic behavior with the effect of the
  \ccode{\&} operator having different behavior based on others of a complex
  expression, or drawn from the type of the left-hand side of an assignment.
  Currently, no similar constructs to qualify or modify operators exist the C
  language.}
\end{description}

Another potential approach, avoided in our work to date, is to support a
silent downcast from a capability-pointer typed \ccode{\&} operator.
In general, we feel strongly that casts from capability-pointer types to
integer-pointer types should generate warnings (or even errors) due to the
potential for lost protection information and confusing outcomes.
In large existing corpora of \hybridCOrCpp{} code, large numbers of warnings
would be produced
\psnote{by what exactly? by having a silent downcast??}
, and likely substantially distract from the goal of
producing safe code.

Regardless of the approach taken, it is important that the compiler warn if
there is a moderate likelihood that an assignment into a capability pointer
might contain default or too-broad bounds compared to the expectation of the
programmer.
Here, both the current CHERI Clang/LLVM and potential future CHERI Clang/LLVM
approaches require explicit warnings be generated, whereas the Morello
approach should avoid surprise at the cost of potentially problematic C
behavior.
\psnote{That last sentence is structured as an opposition -- but warnings and avoiding surprise seem consonant...}

\dcnote{This section is missing any description of C++ references.  I recall
that there were some fun corner cases here, for example if you have a
cap-pointer to an object (which may not be in DDC), what is the type of a
reference to that reference?}

\section{Limitations}

We consider two general sources of limitations, which are inevitably
intertwined:

\begin{itemize}
\item An uncomfortable programming model requiring manual annotation of
  source code
\item Incomplete referential, spatial, and temporal safety
\end{itemize}

\subsection{Programming model}

The \hybridCOrCpp{} programming model is a challenging one requiring
considerable care.
In general, it is our recommendation that the function of \hybridCOrCpp{} is
not improved memory safety, but rather interoperability with more
capability-centered \purecapCOrCpp{} across a fairly hard ABI boundary.
For example, the hybrid CheriBSD kernel variant implements its CheriABI
system-call layer in \hybridCOrCpp{} so that it can interact with capabilities
going to and from pure-capability user processes -- while itself primarily
relying on integer pointers internally.

In C code written to employ \ccode{typedef}s for pointer types, the level
of disruption associated with \uucap{} may not be enormous.
However, the useful setting of bounds is key.
In the use cases we imagine, such as kernel ABI interfaces and IPC libraries,
capabilities are used only in situations in which suitable bounds and
permissions are natural products of the code implementing those services.
For example, if capabilities refer to a shared IPC memory object outside the
DDC-addressable memory of \hybridCOrCpp{} code, then the IPC library has
gained access to that capability from the party that allocated it in a
capability-aware way.
Similarly, hybrid kernels exchanging capabilities with user code will ensure
that suitable bounds are set of capabilities transmitted to userlevel, and
they will also return to the kernel with those bounds (or narrower ones)
intact.

Were more general-purpose programming the aim, a set of extended
capability-aware APIs (e.g., \ccode{malloc\_c()}, \ccode{mmap\_c()}, and so
on), returning and managing capability properties explicitly through
\uucap{}-extended types, would be required.

\subsection{Incomplete referential, spatial, and temporal safety}

\psnote{Hybrid C/C++ / This ?}
This is a relatively weak integration of CHERI support with the language and
run-time environment offering limited memory protection only in very specific
circumstances.
Except where Application Programming Interfaces (APIs) have been extended to
support explicit capability arguments or return values, pointers will not
be protected by capability integrity, pointer provenance validity, bounds,
permissions, or monotonicity.
For example, \cfunc{malloc} will not return pointers as capabilities with
bounds set, and also may not align or pad allocations such that they can be
bounded imprecisely without loss of spatial protection relative to adjacent
allocations.
Further, the control-flow and other data structures used by C and the C
runtime themselves do not use capabilities, and so some of the resilience to
exploitation found in \purecapCOrCpp{}, such as return addresses and stack
pointers implemented using capabilities, are not found in \hybridCOrCpp{}.
Specific limitations by protection type are:

\begin{itemize}
\item Integer pointers, including those returned by default by various memory allocators, do
  not implement capability protections including tag, bounds, and permissions.
  As a result, integer pointers suffer from a lack of provenance validity and
  spatial safety.
  \bdnote{Furthermore, an unmodified allocator may produce allocations lacking
  sufficent alignment support precise bounds.}

\item Whenever a capability pointer type is cast to an integer pointer type,
  its capability metadata, including tag, bounds, and permissions, are lost.
  The resulting integer pointer will be dereferenced relative to the Default
  Data Capability (DDC), and uses those bounds and permissions, which may be
  substantial, and provenance validity is not implemented.

  \dcnote{And, more importantly, casts are not symmetric.  Int to cap pointer
    casts always allow you to access everything with the result that you could
    access with the source.  Caps to int casts may give null.  In to cap to int
    casts are always safe round trips, cap to int to cap may give either a
    capability with more rights or the null capability.}

  \nwfnote{Casts to integers of tag-clear capabilities trap or succeed?}

\item Whenever an integer pointer type is cast to a capability pointer type,
  the compiler will derive the new capability from DDC without refining its
  bounds or permissions, offering provenance validity but not privilege
  minimization.

\item Both explicit function pointers and implied pointers such as return
  addresses and PLT entries are implemented as integer pointers, and therefore
  lack provenance validity, bounds, and permissions.
  Explicit capability pointers will have greater protection, but only subject
  to suitable setting of their metadata.

\item Other data structures implemented by the language runtime and compiler,
  such as the stack, are also implemented using integer pointers that do not
  implement provenance validity, bounds, or permissions.

\item CHERI temporal safety relies on capability implementation of pointers,
  so that the tag, bounds, and permissions can be utilized to detect stale
  pointers to quarantined memory.
  As many pointers in a hybrid program are implemented using integers,
  temporal safety is unable to precisely find all pointers or arrange for
  their suitably atomic replacement.
  \dcnote{I think I'd phrase this slightly differently.  From the perspective
    of revocation, DDC (which encompases the C heap, stack, and image), is a
    single object and so no object reachable from the hybrid heap / stack /
    globals will ever be revoked.}
\end{itemize}

As a result of these limitations, privilege minimization in the language
runtime, control-flow mechanisms, and user data types is largely unimplemented.
Protections are only refined and enforced for programmer-selected types, which
can offer substantial value in specific scenarios, but is not a source of
general robustness for the C and \cpp implementations.
All privilege reductions are programmer-implemented through explicit calls to
narrow bounds and permissions.

\subsection{Origins of bounds and permissions}

Pointers implemented by capabilities by definition carry capability metadata:
tag, bounds, permissions, and so on.
In general, the \hybridCOrCpp{} runtime has much more limited information to
use as inputs for this metadata.
\psnote{...than pure-capability CHERI C/C++ (hmm -- maybe it's worth still keeping the ``pure'' terminology for this document, to make such oppositions clear?)}
Where the address-of operator is used with a capability modifier, linkage
information (such as the captable) can be used as an origin of bounds for
global variables, and the stack allocator itself can provide bounds for local
variables.
Heap allocation requires API extensions that are not currently present (see
above).

\section{Further reading}
\label{sec:further_reading}

The primary reference for the CHERI Instruction-Set Architecture (ISA) is the
ISA specification; at the time of writing, the most recent version is CHERI
ISAv8~\cite{UCAM-CL-TR-951}:

\smallskip
\noindent
\url{https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-951.pdf}
\smallskip

\noindent
Our technical report, \textit{An Introduction to CHERI}, provides a high-level
overview of the CHERI architecture, ISA modeling, hardware implementations,
and software stack~\cite{UCAM-CL-TR-941}:

\smallskip
\noindent
\url{https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-941.pdf}
\smallskip

\noindent
The primary reference for \purecapCOrCpp{} is our technical report,
\textit{CHERI C/C++ Programming Guide}~\cite{UCAM-CL-TR-947}:

\smallskip
\noindent
\url{https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-947.pdf}
\smallskip

\noindent
We published a paper on idiomatic C and spatial memory protection at ASPLOS
2015~\cite{ChisnallCPDP11}:

\smallskip
\noindent
\url{https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/201503-asplos2015-cheri-cmachine.pdf}
\smallskip

\noindent
We published a paper on CheriABI and the adaptation of a complete OS userspace
and application suite to a pure-capability process environment at ASPLOS
2019~\cite{davis2019:cheriabi}:

\smallskip
\noindent
\url{https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/201904-asplos-cheriabi.pdf}
\smallskip

\noindent
We also released an extended technical-report version of this paper that
includes greater implementation detail~\cite{UCAM-CL-TR-932}:

\smallskip
\noindent
\url{https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-932.pdf}
\smallskip

\section{Acknowledgements}

\rwnote{Update feedback acknowledgments here.}

\rwnote{Add authors of CHERI C/C++ Programming Guide who don't end up being
  authors on this document.}

We gratefully acknowledge the helpful feedback from our colleagues, including
Ruben Ayrapetyan, Silviu Baranga, Kevin Brodsky, and Nathaniel Filardo.
This work was supported by the Defense Advanced Research Projects Agency (DARPA) and the Air Force Research Laboratory (AFRL), under contracts
FA8750-10-C-0237 (``CTSRD'') and HR0011-18-C-0016 (``ECATS'').
The views, opinions, and/or findings contained in this report are those of the authors and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.
This work was supported in part by the Innovate UK project Digital Security by
Design (DSbD) Technology Platform Prototype, 105694.
This project has received funding from the European Research Council
(ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement No 789108), ERC Advanced Grant ELVER.
We also acknowledge the EPSRC REMS Programme Grant (EP/K008528/1), Arm Limited,
HP Enterprise, and Google, Inc.
Approved for Public Release, Distribution Unlimited.

\printbibliography

\end{document}
