\documentclass[12pt,twoside,openright,a4paper]{article}
%\documentclass[12pt,twoside,openright,usletter]{article}
% !TeX spellcheck = en_US
%\documentclass[11pt]{article}
% UK date format in bibliography:
\usepackage[british]{babel}
\usepackage[inner=25mm,outer=25mm,top=20mm,bottom=20mm]{geometry}

%\usepackage[UKenglish]{isodate}%UK date endian
\usepackage[headings]{fullpage}
\usepackage[hidelinks]{hyperref}

% Bibliography:
\usepackage[utf8]{inputenc}
\usepackage{csquotes,xpatch}% recommended
% list up to 99 names instead of the default 3
\usepackage[backend=biber,bibencoding=utf8,style=numeric,maxnames=99,backref=false,sortcites,datamodel=thesis]{biblatex}
\addbibresource{cheri.bib}
\AtEveryBibitem{%
% Don't print ISBN,issn, or URL dates
\clearfield{issn}%
\clearfield{isbn}%
\clearfield{urldate}%
\clearfield{urlyear}%
}

\usepackage{bytefield}
\usepackage{color}
\usepackage[scaled=0.8]{DejaVuSansMono}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{mdframed} % To avoid linebreaks in lstlistings
\lstnewenvironment{clisting}[1][]{\endgraf\noindent\minipage{\linewidth}\lstset{language={C},breaklines=true,frame=L,#1}}{\endminipage\endgraf}
\lstnewenvironment{compilerwarning}[1][]{\endgraf\noindent\minipage{\linewidth}\lstset{language={},breaklines=true,basicstyle=\scriptsize\ttfamily\bfseries,frame=L,#1}}{\endminipage\endgraf}

\usepackage{subcaption}
\usepackage{times}
\usepackage{url}
\usepackage[svgnames]{xcolor}
\definecolor{lightgray}{gray}{0.8}
\usepackage{xspace}
\usepackage{xfrac}

\usepackage[nameinlink,noabbrev,capitalise]{cleveref}

% drawing over lstlistings (code stolen from nwf)
\usepackage{tikz}
   \usetikzlibrary{decorations.pathreplacing}
   \usetikzlibrary{fit}
   \usetikzlibrary{tikzmark}
   \usetikzlibrary{calc}
   \usetikzlibrary{patterns}
\newcommand*{\vcpgfmark}[1]{\ensuremath{\vcenter{\hbox{\pgfmark{#1}}}}}
% GBP symbol should be safe since it's easy to enter (at least on a UK keyboard) and won't be in any valid lstlistings
\lstset{escapechar=Â£} % Note: ensure this doesn't occur in any of the code
\newcommand{\TikzListingHighlight}[3][]{\tikz[overlay,remember picture]{\draw[\ifstrempty{#1}{yellow}{#1}, line width=10pt,opacity=0.3](#2) -- (#3);}}
\newcommand*{\TikzListingHighlightStartEnd}[2][]{\tikz[overlay,remember picture]{\draw[\ifstrempty{#1}{yellow}{#1}, line width=10pt,opacity=0.3](pic cs:Start#2) -- (pic cs:End#2);}}


\renewcommand{\UrlFont}{\ttfamily\small}

\newcommand{\baselineboxformatting}[1]{%
  % Measure size of contents
  \sbox0{#1}%
  % Use the difference between the contents' height and the bitbox's height,
  % clamped to [-.44\baselineskip, 0], as our minimum depth.
  \setlength{\skip0}{\ht0 - \height}%
  \ifdim\skip0>0pt%
    \setlength{\skip0}{0}%
  \else%
    \ifdim\skip0<-.44\baselineskip%
      \setlength{\skip0}{-.44\baselineskip}%
    \fi%
  \fi%
  \centering\rule[\skip0]{0pt}{\height}#1}
\bytefieldsetup{boxformatting=\baselineboxformatting}

\lstset{basicstyle=\footnotesize\ttfamily}
%\newcommand{\ccode}[1]{\lstinline[language={C}]{#1}}
%\newcommand{\cxxcode}[1]{\lstinline[language={C++}]{#1}}
\newcommand{\ccode}[1]{{\small\ttfamily{#1}}}
\newcommand{\cxxcode}[1]{{\ccode{#1}}}
\newcommand{\cconst}[1]{{\ccode{#1}}}
\newcommand{\cfunc}[1]{{\ccode{#1()}}}
\newcommand{\cvar}[1]{{\ccode{#1}}}
\newcommand{\pathname}[1]{{\ccode{#1}}}
\newcommand{\commandline}[1]{{\ccode{#1}}}

\newcommand{\ptrdifft}{{\ccode{ptrdiff\_t}}\xspace}
\newcommand{\maxalignt}{{\ccode{max\_align\_t}}\xspace}
\newcommand{\sizet}{{\ccode{size\_t}}\xspace}
\newcommand{\ssizet}{{\ccode{ssize\_t}}\xspace}
\newcommand{\ptraddrt}{{\ccode{ptraddr\_t}}\xspace}
\newcommand{\cuintptrt}{{\ccode{uintptr\_t}}\xspace}
\newcommand{\cintptrt}{{\ccode{intptr\_t}}\xspace}
\newcommand{\ccharstar}{{\ccode{char *}}\xspace}
\newcommand{\cvoidstar}{{\ccode{void *}}\xspace}
\newcommand{\clongt}{{\ccode{long}}\xspace}
\newcommand{\cintt}{{\ccode{int}}\xspace}
\newcommand{\cintttt}{{\ccode{int32\_t}}\xspace}
\newcommand{\cintsft}{{\ccode{int64\_t}}\xspace}
\newcommand{\cintcapt}{{\ccode{intcap\_t}}\xspace}

\newcommand{\uucap}{{\ccode{\_\_capability}}\xspace}

\newcommand{\SIGPROT}{{\ccode{SIGPROT}}\xspace}

\newcommand{\futurevariant}[1]{{\color{blue} #1}}
\newcommand{\morellovariant}[1]{{\color{red} #1}}

\newcommand{\note}[2]{{\color{blue}[ Note: #1 - #2]}}
\usepackage{xstring}
\IfSubStr*{\jobname}{final}{
  \renewcommand{\note}[2]{\relax\ifhmode\unskip\fi}
}{
  % show comments by default
}

\newcommand{\arnote}[1]{\note{#1}{Alex R.}}
\newcommand{\bdnote}[1]{\note{#1}{Brooks D.}}
\newcommand{\rwnote}[1]{\note{#1}{Robert W.}}
\newcommand{\amnote}[1]{\note{#1}{Alfredo M.}}
\newcommand{\psnote}[1]{\note{#1}{Peter S.}}
\newcommand{\pgnnote}[1]{\note{#1}{Peter N.}}
\newcommand{\jrtcnote}[1]{\note{#1}{Jess C.}}
\newcommand{\hmnote}[1]{\note{#1}{Hesham A.}}
\newcommand{\nwfnote}[1]{\note{#1}{nwf}}

% typeset C++ sensibly
% NB: \nolinebreak was only made robust upstream on 2019-08-20
\usepackage{relsize}
\newcommand*{\cpp}{\texorpdfstring{C\textsmaller[2]{\protect\nolinebreak[4]\hspace{-.05em}\raisebox{.45ex}{\textbf{++}}}}{C++}}
\newcommand*{\COrCpp}{C/\cpp{}}
\newcommand*{\purecapCOrCpp}{CHERI \COrCpp{}}
\newcommand*{\CHERIhybridCOrCpp}{CHERI Hybrid \COrCpp{}}
\newcommand*{\hybridCOrCpp}{Hybrid \COrCpp{}}

\hyphenation{Free-BSD}
\hyphenation{Free-RTOS}
\hyphenation{Cheri-BSD}
\hyphenation{Cheri-Free-RTOS}
\hyphenation{Cheri-ABI}
\hyphenation{Web-Kit}
\hyphenation{Postgre-SQL}

\title{Review Draft: \\
  \CHERIhybridCOrCpp{} Programming Guide \\
  (DRAFT)}
\author{Robert~N.~M.~Watson$^*$,
    Alexander~Richardson$^*$,
    Jessica~Clarke$^*$, \\
    John Baldwin$^\ddagger$,
    David Chisnall$^\S$,
    Brooks Davis$^\dagger$,
    Simon W. Moore$^*$, \\
    Peter~G.~Neumann$^\dagger$
  \\
    \textbf{(others to be added)}
  \\
  \\
  $^*$University of Cambridge, $^\dagger$SRI International, \\
  $^\ddagger$Ararat River Consulting, LLC and $^\S$Microsoft Research}
%
%Alexander Richardson$^*$,
%  Brooks Davis$^\dagger$, \\
%  John Baldwin$^\ddagger$, David Chisnall$^\S$, Jessica Clarke$^*$,
%  Nathaniel Filardo$^*$, \\
%  Simon W. Moore$^*$,  Edward Napierala$^*$, Peter Sewell$^*$, and \\
%  Peter G. Neumann$^\dagger$ \\
%  \\

\begin{document}
\sloppy

%% CL tech-report format provides its own cover page.  Comment for final
%% version.
\maketitle

%% CL tech-report format requires page numbering to start at 3.  Uncomment for
%% final version.
%\setcounter{page}{3}
%%

%
% Keep Abstract in sync with the Introduction.
%
\newcommand{\abstracttext}{

This document is an introduction to the \CHERIhybridCOrCpp{} programming
language.
\hybridCOrCpp{} allows the selective use of CHERI capabilities from within an
otherwise unmodified, and Application Binary Interface (ABI)-compatible,
C/\cpp{}-language code base.
Its aim is to allow management of, and interoperation with, capability-enabled
code while using an integer rather than capability pointer implementation
internally.
Unlike in \purecapCOrCpp{}, \hybridCOrCpp{} defaults to an integer
implementation for pointers except where specifically annotated in the
program source code.
Due to the requirement for ABI compatibility, implied pointers within the
language runtime itself are also primarily implemented as integers rather than
capabilities.

\hybridCOrCpp{} primarily sees use in specialized low-level systems code that,
for compatibility or performance reasons, must use non-capability pointers.
Current use cases includes boot loaders, operating-system kernels, and
Inter-Process Communication (IPC) runtimes.
Potential future use cases include programs that have been formally verified
(which do not require dynamic memory safety) and language runtimes (which may
have high dynamic pointer memory access patterns making wider pointer sizes
unrealistic).

\nwfnote{Is that really about the \emph{access} pattern or more the
\emph{density} of pointers in memory?  I would imagine that people usually
object to the increased footprint before they object to the increased DRAM
traffic implied by moving larger pointers around?}

\nwfnote{Do you want to call out partially adapted compartmentalized programs
(possibly inclusive of programs with their own runtime systems; one could
imagine enriching JS to have a ForeignCapability type, e.g.) as another
possible example where being able to exchange capabilities might be useful
despite possibly having a non-NULL DDC?}

%Hybrid code is used in the CheriBSD kernel, and in the userspace run-time
%environment for hybrid processes to enable communication with pure-capability
%processes via co-process IPC.
Because the benefits of referential, spatial, and temporal memory safety are
unavailable to both the program and language runtime, care should be utilized,
and its use should be avoided where not strictly necessary.

\nwfnote{``its'' is not very clear (and might plausibly, syntactically, refer
to ``care''); maybe ``\hybridCOrCpp{} should be used only where strictly
necessary''?}
}

\newcommand{\reviewwarning}{
\textbf{
As \hybridCOrCpp{} remains an area of active research and development, this
report is a request for review and comments rather than a specification.
}
\rwnote{This last sentence will go away in a final version.}
}

\begin{abstract}
\abstracttext

\reviewwarning
\end{abstract}

\newpage
\setcounter{tocdepth}{2}
\tableofcontents

\newpage

\section{Introduction}

%
% Keep Abstract in sync with the Introduction.
%
\abstracttext

This is a companion to the \textit{\purecapCOrCpp{} Programming
Guide}~\cite{UCAM-CL-TR-947}, and refers to that report rather than
replicating its contents.
Readers will benefit from having read that document prior to this one, as
many behaviors in \hybridCOrCpp{} are based on those in \purecapCOrCpp{}, or
will be contrasted with it in this guide.
The \textit{Introduction to CHERI} technical
report~\cite{UCAM-CL-TR-941} also provides background material for this
guide.

\subsection{Document structure}

This report describes:

\begin{itemize}
\item The objectives and potential use cases for \CHERIhybridCOrCpp{};
\item How \hybridCOrCpp{} interacts with explicit pointers in program source
  code, as well as implied pointers in the language runtime;
\item The impact of \hybridCOrCpp{} on C-language types, casts and the address-of operator
  (\ccode{\&});
\item A number of inherent and practical implications to \hybridCOrCpp{}; and
\item Further reading relating to CHERI and \COrCpp{} on CHERI.
\end{itemize}

\subsection{Status of this document}

This document is a request for comments and feedback, and not a stable
specification.
This document currently describes three variants of \hybridCOrCpp{}:

\begin{enumerate}
\item \hybridCOrCpp{} as implemented in the CHERI Clang/LLVM implementation on
  CHERI-MIPS and CHERI-RISC-V.

  Unless otherwise indicated, all statements refer to this model.

\item \hybridCOrCpp{} as implemented in the CHERI Clang/LLVM implementation on
  Morello (which differs in small but important ways).

  Key differences are in \morellovariant{red text}.

\item Our current thinking on next directions for \hybridCOrCpp{}.

  Key differences are in \futurevariant{blue text}.
\end{enumerate}

\noindent
We have attempted to clearly comment on these behavioral divergences where
required.
It is our aim to achieve convergence of these approaches so that a single
\CHERIhybridCOrCpp{} can be used across all architectures, and best addresses
all use cases.
Feedback on this draft may be submitted via pull requests or the issue tracker
on our GitHub repository for the report:

\smallskip

\url{https://github.com/CTSRD-CHERI/cheri-hybrid-c-guide}

\section{Objective and use cases for \hybridCOrCpp{}}

\hybridCOrCpp{} aims to allow programs to be written to use conventional
integer pointers throughout their implementations, and yet also to interact
with capabilites via modest C-language extensions causing specifically
annotated pointers to be implemented using capabilities.
This is in contrast to \purecapCOrCpp{}, which implements all pointers as
capabilities by default, and whose aim is strong referential, spatial, and
temporal memory protection for C/\cpp{}.
While \hybridCOrCpp{} is unable to provide strong referential, spatial, or
temporal safety in most use cases, it allows conventional
integer-pointer-based code to interact usefully with capabilities in a number
of specific use cases.

\subsection{Hybrid CheriBSD kernel}

CheriBSD implements two kernel variants: a \hybridCOrCpp{} compilation, and a
\purecapCOrCpp{} variant.
In the former, the aim is to support a CHERI-enabled userspace without
substantive change to kernel-internal protection.
In the latter, the aim is to also use CHERI memory protection within the
kernel.
Both kernel variants support hybrid and pure-capability (CheriABI) userspace
process environments.

The \hybridCOrCpp{}-compiled CheriBSD kernel is almost entirely implemented
in conventional \COrCpp{} using integer pointers, except for its handling of
system-call arguments and capability state, which is manually annotated.
Capability pointers are used in the kernel for three reasons:

\begin{enumerate}
\item To manage the dynamic state of capability-enabled kernel and user
  threads as part of context management and exception handling;

\item In the implementation of tag-enabled virtual-memory abstractions, such
  as copy-on-write; and

\item To handle pointer-type userspace system-call arguments as capabilities
  rather than integer pointers, both to enable capability-based behaviors
  (such as having opaque pointer types used in POSIX asynchronous I/O be able
  to hold capabilities), and to prevent confused deputy attacks (such as might
  occur if an omnipotent kernel ignored userspace-originated bounds on stack
  or heap allocations).
\end{enumerate}

In order to unify system-call handling, user pointers originating in hybrid
ABI processes are converted into capability pointers at the system-call
boundary.
This leads to coarse-grained bounds, but, for example, permit user pointers to
be used only in accessing userspace memory.
For pure-capability (CheriABI) processes, user pointer types originate as
capabilities, and are simply propagated as necessary.

\subsection{The CheriBSD hybrid process environment}

In the usermode portion of the CheriBSD hybrid ABI process environment, some
system libraries are extended with modest capability annotations to support
capability use.
For example, \ccode{memcpy()} and \ccode{sort()} must propagate tags rather
than perform byte-wise copies, in order to preserve pointers embedded in data
structures across memory copies.

\rwnote{More here}

\subsection{Co-process IPC libraries in hybrid processes}

\rwnote{More here}

\subsection{Hybrid language runtimes}

\section{Pointer implementation}

\subsection{Architectural implementations of pointers}

Pointers may be implemented using two underlaying architectural types:

\begin{description}
\item[Integer pointers] are pointers implemented as integers.
  Storage size and alignment will be the architectural address size (e.g.,
  64 bits on a 64-bit architecture in a 64-bit process environment).

  Generated code will utilize integer load and store instructions to access
  variables of these types, and dereference them using integer-relative
  instructions.

  Explicit pointers will be of this type by default.
  Implied pointers will be of this type if required by the existing ABI.

\item[Capability pointers] are pointers implemented using capabilities.
  Storage size and alignment will be the architectural capability size (e.g.,
  128 bits on a 64-bit architecture in a 64-bit process environment).

  Generated code will utilize capability load and store instructions to access
  variables of these types, and dereference them using capability-relative
  instructions.

  Explicit pointers will only be of this type if specifically annotated in the
  program source.
  Implied pointers may be of this type if it does not harm the ABI; some
  implied pointers may be replicated in order to allow both types to be used
  (e.g., by providing a GOT and a captable).
\end{description}

\subsection{Pointers in source code, code generation, and the runtime}

We are concerned with pointers arising from two parts of the C implementation:

\begin{description}
\item[Explicit pointers] are pointers visible in the program source.
  These include declared pointers taken to local, global, or thread-local
  variables, to functions, or pointers to returned heap allocations.
  In \hybridCOrCpp{}, these pointers will be implemented using capabilities
  only if specifically annotated.

\item[Implied pointers] are those used by the language runtime and generated
  code to manage the language implementation itself.
  This includes the stack pointer, program counter and return addresses, PLT
  entries, vtable pointers, and GOT/captable pointers.
  In \hybridCOrCpp{}, these pointers will be implemented using integers,
  although in some cases underlying data structures will be replicated to
  provide capability versions of them -- e.g., of the GOT.
\end{description}

\subsection{Explicit pointers}

Explicit pointers can be implemented as capability pointers in several ways:

\begin{description}
\item[Pointers qualified with \uucap{}]
  To implement an explicit pointer as a capability in \hybridCOrCpp{}, the
  qualifier \uucap{} is used on a pointer type.
  For example, \ccode{char * \_\_capability c} declares a capability pointer
  to a \ccode{char}.
  Unqualified explicit pointers will be implemented as integer pointers.

\item[Other pointers that have no ABI impact]
  \futurevariant{There are opportunities to compile code using capability
  pointers, where using a different underlying architectural type has no
  impact on the ABI exposed (or potentially exposed) to other code.
  For example, unescaped pointers to local variables may be suitable for
  capability-pointer compilation.
  Other constraints may exist, such as the non-embedding of the pointer's size
  in escaped values.
  Further research is required to evaluate the viability and usefulness of
  this potential approach.}

\item[Other pointers that have a policy-contrained ABI impact]
  \futurevariant{There is also the opportunity to have a policy-determined
  impact on ABI, in which an explicit policy might allow compilation of
  larger portions of code in a manner that more substantively impacts ABI.
  Such policies might explicitly identify function types and data structures
  (e.g., public APIs) with public ABI guarantees while permitting substantial
  variation in other compiled code (e.g., private APIs).
  Further research is required to evaluate the viability and usefulness of
  this potential approach.}
\end{description}

\nwfnote{Is that ``policy-constrained'' or ``policy-contained'' or something else?}

\rwnote{Do we want a new item, ``Implied pointers that have a limited impact
  on ABI''?  E.g., to capture the CRA case?}

\rwnote{Have we gotten too researchy here, and we should just stick to the
  simple story that only those tagged with \uucap{} matter.
  I seem to recall that we also have a pragma for managing the default
  interpretation to be used in header files shared between interpretations...}

\subsection{Implied pointers}

We consider three cases:

\begin{description}
\item[Implied pointers critical to the ABI]
  Wherever the ABI dictates that implied pointers must be integer pointers,
  that will be maintained by \hybridCOrCpp{} code generation and in the
  language runtime.
  For example, the hybrid ABI requires that the stack pointer be an integer
  pointer.

\item[Implied pointers invisible to the ABI]
  In some cases, implied pointers may be implemented as capability pointers
  without impacting the ABI.

  {\color{blue} For example, hybrid code could use a capability return address
  rather than an integer return address to provide pointer provenance validity
  for the return address, even if not tight bounds, as the return address is
  not part of the ABI to other functions.}
  \jrtcnote{\cfunc{\_\_builtin\_return\_address} does leak these implied
  pointers to some code, and it has implications for things like libunwind, so
  it does affect the ABI. Also the kernel needs to know to put a capability in
  CRA in order for signal handlers to be able to return to \cfunc{sigcode}.
  There's a lot of subtlety here that needs to be captured.}
  \rwnote{I'd been pondering whether the ABI might allow us to use a return
  capability, but in which unwind/etc only looked at the lower 64 bits...  And
  I suppose the builtin could be polymorphic.  But signals are indeed a messy
  issue.
  Is there a better example we could give?}

\item[Implied pointers that can be replicated as integer and capability
  pointers]
  In other cases, implied pointers may be replicated, with a full set of
  integer pointer variants provided for the existing ABI, but additional
  capability pointer variants provided for hybrid code.

  \futurevariant{For example, a separate captable could be provided,
  replicating the set of entries in the existing GOT, to allow capability
  pointers taken to global variables to have desired bounds and permissions.}

  \morellovariant{In the Morello ABI, capability pointers taken to globals
  pick up bounds and other metadata from constant pools of capabilities,
  effectively small per-function captables manually created by the compiler.}
\end{description}

\section{C-language types}
\label{sec:c-language-types}

\rwnote{This needs updating for hybrid use.}

As confusion frequently arises about the most appropriate types to use for
integers, pointers, and pointer-related values, we make the following
recommendations:

\begin{description}
\item[\cintt, \cintttt, \clongt, \cintsft,
  \ldots{}] These pure integer types should be used to hold integer values
  that will never be cast to a pointer type without first combining them with
  another pointer value -- e.g., by using them as an array offset.
  Most integers in a C/\cpp{}-language program will be of these types.

\item[\ptraddrt] This is a new integer type introduced by CHERI C and should be used to hold
  addresses.
  \ptraddrt should not be directly cast to a pointer type for
  dereference; instead, it must be combined with an existing valid capability
  to the address space to generate a dereferenceable pointer.
  Typically, this is done using the \ccode{cheri\_address\_set(c, x)} function.

\item[\sizet, \ssizet] These integer types should be used
  to hold the unsigned or signed lengths of regions of address space.
  \arnote{\sizet not necessary the same as unsigned \ptrdifft.}

\item[\ptrdifft] This integer type describes the difference of indices
  between two pointers to elements of the same array, and should not be used for
any other purpose.
  It can be added to a pointer to obtain a new pointer, but the result will
  be dereferenceable only if the address lies within the bounds of the
  pointer from which it was derived.

  \note{Isn't that last sentence true of any combination?}{nwf}

  Less standards-compliant code sometimes uses \ptrdifft when the
  programmer more likely meant \cintptrt or (less commonly)
  \sizet.
  When porting code, it is worthwhile to audit use of \ptrdifft.

  \note{Should we recommend that \sizet be used to hold lengths of
  allocations and \ptrdifft be used to talk about spans of
  address space (e.g., the offsets between two subobjects of an allocation)?  I feel
  like the recommendations here are not as concrete as I'd like.}{nwf}

\item[\cintptrt, \cuintptrt] These integer types should be
  used to hold values that may be valid pointers if cast back to a pointer
  type.
  When an \cintptrt is assigned an integer value -- e.g., due to
  constant initialization to an integer in the source -- and the result is
  cast to a pointer type, the pointer will be invalid and hence
  non-dereferenceable.
  These types will be used in two cases: (1) Where there is uncertainty as to
  whether the value to be held will be an integer or a pointer -- e.g., for an
  opaque argument to a callback function; or (2) Where it is more convenient
  to place a pointer value in an integer type for the purposes of arithmetic
  (which takes place on the capability's address and in units of bytes, as if
  the pointer had been cast to \texttt{char *}).

  The observable, integer range of a \cuintptrt is the same as
  that of a \ptraddrt (or \ptrdifft for \cintptrt), despite the increased \emph{alignment} and \emph{storage} requirements.

\item[\ccode{intmax\_t}, \ccode{uintmax\_t}] According to the C standard\arnote{7.20.1.5 Greatest-width integer types}, these integer types should be \enquote{capable of representing any value of any (unsigned) integer type}.
  In \purecapCOrCpp{}, they are not provenance-carrying and can represent the integer \emph{range} of \cuintptrt/\cintptrt, but not the capability metadata or tag bit.
  As the observable value of \cuintptrt/\cintptrt is the pointer address range, we believe this choice to be compatible with the C standard.

  Additionally, due to ABI constraints, it would be extremely difficult to change the width of these types from 64 to 129 bits.
  This is also true for other architectures such as x86: despite Clang and GCC supporting an \ccode{\_\_int128} type, \ccode{intmax\_t} remains 64 bits wide.

  We generally do not recommend use of these types in \purecapCOrCpp{}.
  However, the types may be useful in \cfunc{printf} calls (using the \ccode{\%j} format string width modifier) as the \pathname{inttypes.h} \ccode{PRI*} macros can be rather verbose.


\item[\maxalignt] This type is defined in C as \enquote{an object type whose alignment is the greatest fundamental alignment} \arnote{C2x \S{}7.19.2} and this includes capability types for \purecapCOrCpp{}.
% and in \cpp{} as a \enquote{type whose alignment requirement is at least as great as that of every scalar type}\arnote{C++17 \S{}21.2.4p5}
We found that some custom allocators use \ccode{sizeof(long double)} or \ccode{sizeof(uint64\_t)} to align their return values.
While this appears to work on most architectures, in \purecapCOrCpp{} this must be changed to \ccode{alignof(\maxalignt)}\kern-2pt.%
%
\footnote{%
It is important to use \ccode{alignof} instead of \ccode{sizeof} since many
common implementations, such as GCC and FreeBSD, define \maxalignt as a
\ccode{struct} and not a \ccode{union}.}

\item[\ccharstar, \ldots{}] These pointer types are suitable for
  dereference, but in general \psnote{that ``in general'' makes me wonder about the exceptions?}
  \arnote{The only exception I can think of is requiring \cvoidstar due to bad API design (callback parameters, etc).}  should not be cast to or from arbitrary integer
  values.
  Valid pointers are always derived from other valid pointers (including those cast to \cintptrt or \cuintptrt), and cannot be
  constructed using arbitrary integer arithmetic.
\end{description}

It is important to note that \cuintptrt is no longer the same size as
\sizet. This difference may require making some changes to
existing code to use the correct type depending on whether the variable
needs to be able store a pointer type. In cases where this is not obvious
(such as for a callback argument), we recommend the use of \cuintptrt.
This ensures that provenance is maintained.

\pgnnote{The above section begs questions relating to what is the
  responsibility of programmers and what can be aided or managed by
  compilers.  Ideally, the latter would be preferable to requiring
  programmers to understand things are possibly beyond their so-called
  experience.}

\subsection{intptr\_t}

\cintptrt{} is an integer type able to hold a \cvoidstar{} pointer.
In \purecapCOrCpp{}, \cintptrt{} is implemented using the \cintcapt{}
type, which has sufficient size and alignment to hold a capability.
In \hybridCOrCpp{}, \cintptrt{} is the native integer pointer type for the
architecture (often a \clongt{}), and by definition too small (and may be
insufficiently aligned) to hold a capability.
\hybridCOrCpp{} continues to provide a suitable \cintcapt{} (i.e., one that
can hold a capability), but this will be used only
by code aware of the hybrid programming model.

In general, capability-unaware code will execute unchanged, but
capability-aware code may be limited in how it can utilize capability pointers.
For example, existing APIs using \cintptrt{} will not be able to accept or
return capability pointers, only integer pointers, which may be problematic
for some code bases -- e.g., those using \cintptrt{} to hold opaque handles
passed to function callback in asynchronous programming models.
Another example might be language runtimes that assume that \cintptrt{} is
suitable storage for both integers and all pointers -- they will operate fine,
but converting to using capabilities may be a substantial effort.

\section{Casts between integer and capability pointers}

\rwnote{This section onwards a work in progress.}

\subsection{Casts from integer to capability pointers}

Casts from integer pointers to capability pointers will silently \rwnote{is
this still true?} generate a capability pointer value derived from the
Default Data Capability (DDC).

\nwfnote{Recommend \ccode{cheri\_address\_set}?}

\subsection{Casts from capability to integer pointers}

Casts from capability pointers to integer pointers will take on a value that
is the integer difference between the address of the capability pointer and
the address of DDC.

\rwnote{DDC}

\section{\& operator}

The \ccode{\&} operator takes the address of a C or \cpp{} variable, and
returns a pointer of a corresponding type.
We consider three approaches:

\begin{description}
\item[Integer pointer interpretation] is the approach taken by CHERI
  Clang/LLVM.
  In this approach, \ccode{\&} returns an integer pointer type, the default
  pointer type in \hybridCOrCpp{}.
  If then assigned to a capability pointer, the resulting bounds and
  permissions are derived from the Default Data Capability (DDC).

\nwfnote{Does that mean that I can't write something like...  \ccode{struct \{
int x; int y; \} * \_\_capability sp; int * \_\_capability xp = \&sp->x;} and
have it work unless \ccode{sp} is a subset of DDC?  I'd sort of expect \& to be
polymorphic in its argument, even if it isn't polymorphic in its return type as
given next.}

\item[Polymorphic \ccode{\&}] \morellovariant{is the approach taken by Morello
  Clang/LLVM.
  In this approach, \ccode{\&} is polymorphic: if assigned to a capability
  pointer, the resulting bounds and permissions are those of the underlying
  type.}
  \rwnote{Or are they of the underlying storage?}

\item[Qualified \ccode{\&}]
  \futurevariant{This approach would qualify or modify the \ccode{\&} operator
  itself, perhaps in the form \ccode{\_\_capability \&}.
  This approach would avoid polymorphic behavior with the effect of the
  \ccode{\&} operator having different behavior based on otherts of a complex
  expression, or drawn from the type of the left-hand side of an assignment.
  Currently, no similar constructs to qualify or modify operators exist the C
  language.}
\end{description}

Another potential approach, avoided in our work to date, is to support a
silent downcast from a capability-pointer typed \ccode{\&} operator.
In general, we feel strongly that casts from capability-pointer types to
integer-pointer types should generate warnings (or even errors) due to the
potential for lost protection information and confusing outcomes.
In large existing corpora of \hybridCOrCpp{} code, large numbers of warnings
would be produced, and likely substantially distract from the goal of
producing safe code.

Regardless of the approach taken, it is important that the compiler warn if
there is a moderate likelihood that an assignment into a capability pointer
might contain default or too-broad bounds compared to the expectation of the
programmer.
Here, both the current CHERI Clang/LLVM and potential future CHERI Clang/LLVM
approaches require explicit warnings be generated, whereas the Morello
approach should avoid surprise at the cost of potentially problematic C
behavior.

\section{Limitations}

We consider two general sources of limitations, which are inevitably
intertwined:

\begin{itemize}
\item An uncomfortable programming model requiring manual annotation of
  source code
\item Incomplete referential, spatial, and temporal safety
\end{itemize}

\subsection{Programming model}

The \hybridCOrCpp{} programming model is a challenging one requiring
considerable care.
In general, it is our recommendation that the function of \hybridCOrCpp{} is
not improved memory safety, but rather interoperability with more
capability-centered \purecapCOrCpp{} across a fairly hard ABI boundary.
For example, the hybrid CheriBSD kernel variant implements its CheriABI
system-call layer in \hybridCOrCpp{} so that it can interact with capabilities
going to and from pure-capability user processes -- while itself primarily
relying on integer pointers internally.

In C code written to employ \ccode{typedef}s for pointer types, the level
of disruption associated with \uucap{} may not be enormous.
However, the useful setting of bounds is key.
In the use cases we imagine, such as kernel ABI interfaces and IPC libraries,
capabilities are used only in situtations in which suitable bounds and
permissions are natural products of the code implementing those services.
For example, if capabilities refer to a shared IPC memory object outside the
DDC-addressable memory of \hybridCOrCpp{} code, then the IPC library has
gained access to that capability from the party that allocated it in a
capability-aware way.
Similarly, hybrid kernels exchanging capabilities with user code will ensure
that suitable bounds are set of capabilities transmitted to userlevel, and
they will also return to the kernel with those bounds (or narrower ones)
intact.

Were more general-purpose programming the aim, a set of extended
capability-aware APIs (e.g., \ccode{malloc\_c()}, \ccode{mmap\_c()}, and so
on), returning and managing capability properties explicitly through
\uucap{}-extended types, would be required.

\subsection{Incomplete referential, spatial, and temporal safety}

This is a relatively weak integration of CHERI support with the language and
run-time environment offering limited memory protection only in very specific
circumstances.
Except where Application Programming Interfaces (APIs) have been extended to
support explicit capability arguments or return values, pointers will not
be protected by capability integrity, pointer provenance validity, bounds,
permissions, or monotonicity.
For example, \cfunc{malloc} will not return pointers as capabilities with
bounds set, and also may not align or pad allocations such that they can be
bounded imprecisely without loss of spatial protection relative to adjacent
allocations.
Further, the control-flow and other data structures used by C and the C
runtime themselves do not use capabilities, and so some of the resilience to
exploitation found in \purecapCOrCpp{}, such as return addresses and stack
pointers implemented using capabilities, are not found in \hybridCOrCpp{}.
Specific limitations by protection type are:

\begin{itemize}
\item Integer pointers, including those returned by default by various memory allocators, do
  not implement capability protections including tag, bounds, and permissions.
  As a result, integer pointers suffer from a lack of provenance validity and
  spatial safety.

\item Whenever a capability pointer type is cast to an integer pointer type,
  its capability metadata, including tag, bounds, and permissions, are lost.
  The resulting integer pointer will be dereferenced relative to the Default
  Data Capability (DDC), and uses those bounds and permissions, which may be
  substantial, and provenance validity is not implemented.

  \nwfnote{Casts to integers of tag-clear capabilities trap or succeed?}

\item Whenever an integer pointer type is cast to a capability pointer type,
  the compiler will derive the new capability from DDC without refining its
  bounds or permissions, offering provenance validity but not privilege
  minimization.

\item Both explicit function pointers and implied pointers such as return
  addresses and PLT entries are implemented as integer pointers, and therefore
  lack provenance validity, bounds, and permissions.

\item Other data structures implemented by the language runtime and compiler,
  such as the stack, are also implemented using integer pointers that do not
  implement provenance validity, bounds, or permissions.

\item CHERI temporal safety relies on capability implementation of pointers,
  so that the tag, bounds, and permissions can be utilized to detect stale
  pointers to quarantined memory.
  As many pointers in a hybrid program are implemented using integers,
  temporal safety is unable to precisely find all pointers or arrange for
  their suitably atomic replacement.
\end{itemize}

As a result of these limitations, privilege minimization in the language
runtime, control-flow mechanisms, and user data types is largely unimplementd.
Protections are only refined and enforced for programmer-selected types, which
can offer substantial value in specific scenarios, but is not a source of
general robustness for the C and \cpp implementations.
All privilege reductions are programmer-implemented through explicit calls to
narrow bounds and permissions.

\subsection{Origins of bounds and permissions}

Pointers implemented by capabilities by definition carry capability metadata:
tag, bounds, permissions, and so on.




\section{Further reading}
\label{sec:further_reading}

\rwnote{Update: The two real references are likely the CHERI C/C++ guide and
the Introduction to CHERI report}

The primary reference for the CHERI Instruction-Set Architecture (ISA) is the
ISA specification; at the time of writing, the most recent version is CHERI
ISAv7~\cite{UCAM-CL-TR-927}:

\smallskip
\noindent
\url{https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-927.pdf}
\smallskip

\noindent
Our technical report, \textit{An Introduction to CHERI}, provides a high-level
overview of the CHERI architecture, ISA modeling, hardware implementations,
and software stack~\cite{UCAM-CL-TR-941}:

\smallskip
\noindent
\url{https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-941.pdf}
\smallskip

\section{Acknowledgements}

\rwnote{Update feedback acknowledgments here.}

\rwnote{Add authors of CHERI C/C++ Programming Guide who don't end up being
  authors on this document.}

We gratefully acknowledge the helpful feedback from our colleagues, including
Hesham Almatary,
Ruben Ayrapetyan, Silviu Baranga, Jacob Bramley, Rod Chapman, Paul Gotch, Al Grant,
Brett Gutstein, Alfredo Mazzinghi, Alan Mycroft, and Lee Smith.
This work was supported by the Defense Advanced Research Projects Agency (DARPA) and the Air Force Research Laboratory (AFRL), under contracts
FA8750-10-C-0237 (``CTSRD'') and HR0011-18-C-0016 (``ECATS'').
The views, opinions, and/or findings contained in this report are those of the authors and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.
This work was supported in part by the Innovate UK project Digital Security by
Design (DSbD) Technology Platform Prototype, 105694.
This project has received funding from the European Research Council
(ERC) under the European Unionâs Horizon 2020 research and innovation programme (grant agreement No 789108), ERC Advanced Grant ELVER.
We also acknowledge the EPSRC REMS Programme Grant (EP/K008528/1), Arm Limited,
HP Enterprise, and Google, Inc.
Approved for Public Release, Distribution Unlimited.

\printbibliography

\end{document}
