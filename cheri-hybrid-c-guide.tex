\documentclass[12pt,twoside,openright,a4paper]{article}
%\documentclass[12pt,twoside,openright,usletter]{article}
% !TeX spellcheck = en_US
%\documentclass[11pt]{article}
% UK date format in bibliography:
\usepackage[british]{babel}
\usepackage[inner=25mm,outer=25mm,top=20mm,bottom=20mm]{geometry}

%\usepackage[UKenglish]{isodate}%UK date endian
\usepackage[headings]{fullpage}
\usepackage[hidelinks]{hyperref}

% Bibliography:
\usepackage[utf8]{inputenc}
\usepackage{csquotes,xpatch}% recommended
% list up to 99 names instead of the default 3
\usepackage[backend=biber,bibencoding=utf8,style=numeric,maxnames=99,backref=false,sortcites,datamodel=thesis]{biblatex}
\addbibresource{cheri.bib}
\AtEveryBibitem{%
% Don't print ISBN,issn, or URL dates
\clearfield{issn}%
\clearfield{isbn}%
\clearfield{urldate}%
\clearfield{urlyear}%
}

\usepackage{bytefield}
\usepackage{color}
\usepackage[scaled=0.8]{DejaVuSansMono}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{mdframed} % To avoid linebreaks in lstlistings
\lstnewenvironment{clisting}[1][]{\endgraf\noindent\minipage{\linewidth}\lstset{language={C},breaklines=true,frame=L,#1}}{\endminipage\endgraf}
\lstnewenvironment{compilerwarning}[1][]{\endgraf\noindent\minipage{\linewidth}\lstset{language={},breaklines=true,basicstyle=\scriptsize\ttfamily\bfseries,frame=L,#1}}{\endminipage\endgraf}

\usepackage{subcaption}
\usepackage{times}
\usepackage{url}
\usepackage[svgnames]{xcolor}
\definecolor{lightgray}{gray}{0.8}
\usepackage{xspace}
\usepackage{xfrac}

\usepackage[nameinlink,noabbrev,capitalise]{cleveref}

% drawing over lstlistings (code stolen from nwf)
\usepackage{tikz}
   \usetikzlibrary{decorations.pathreplacing}
   \usetikzlibrary{fit}
   \usetikzlibrary{tikzmark}
   \usetikzlibrary{calc}
   \usetikzlibrary{patterns}
\newcommand*{\vcpgfmark}[1]{\ensuremath{\vcenter{\hbox{\pgfmark{#1}}}}}
% GBP symbol should be safe since it's easy to enter (at least on a UK keyboard) and won't be in any valid lstlistings
\lstset{escapechar=Â£} % Note: ensure this doesn't occur in any of the code
\newcommand{\TikzListingHighlight}[3][]{\tikz[overlay,remember picture]{\draw[\ifstrempty{#1}{yellow}{#1}, line width=10pt,opacity=0.3](#2) -- (#3);}}
\newcommand*{\TikzListingHighlightStartEnd}[2][]{\tikz[overlay,remember picture]{\draw[\ifstrempty{#1}{yellow}{#1}, line width=10pt,opacity=0.3](pic cs:Start#2) -- (pic cs:End#2);}}


\renewcommand{\UrlFont}{\ttfamily\small}

\newcommand{\baselineboxformatting}[1]{%
  % Measure size of contents
  \sbox0{#1}%
  % Use the difference between the contents' height and the bitbox's height,
  % clamped to [-.44\baselineskip, 0], as our minimum depth.
  \setlength{\skip0}{\ht0 - \height}%
  \ifdim\skip0>0pt%
    \setlength{\skip0}{0}%
  \else%
    \ifdim\skip0<-.44\baselineskip%
      \setlength{\skip0}{-.44\baselineskip}%
    \fi%
  \fi%
  \centering\rule[\skip0]{0pt}{\height}#1}
\bytefieldsetup{boxformatting=\baselineboxformatting}

\lstset{basicstyle=\footnotesize\ttfamily}
%\newcommand{\ccode}[1]{\lstinline[language={C}]{#1}}
%\newcommand{\cxxcode}[1]{\lstinline[language={C++}]{#1}}
\newcommand{\ccode}[1]{{\small\ttfamily{#1}}}
\newcommand{\cxxcode}[1]{{\ccode{#1}}}
\newcommand{\cconst}[1]{{\ccode{#1}}}
\newcommand{\cfunc}[1]{{\ccode{#1()}}}
\newcommand{\cvar}[1]{{\ccode{#1}}}
\newcommand{\pathname}[1]{{\ccode{#1}}}
\newcommand{\commandline}[1]{{\ccode{#1}}}

\newcommand{\ptrdifft}{{\ccode{ptrdiff\_t}}\xspace}
\newcommand{\maxalignt}{{\ccode{max\_align\_t}}\xspace}
\newcommand{\sizet}{{\ccode{size\_t}}\xspace}
\newcommand{\ssizet}{{\ccode{ssize\_t}}\xspace}
\newcommand{\ptraddrt}{{\ccode{ptraddr\_t}}\xspace}
\newcommand{\cuintptrt}{{\ccode{uintptr\_t}}\xspace}
\newcommand{\cintptrt}{{\ccode{intptr\_t}}\xspace}
\newcommand{\ccharstar}{{\ccode{char *}}\xspace}
\newcommand{\cvoidstar}{{\ccode{void *}}\xspace}
\newcommand{\clongt}{{\ccode{long}}\xspace}
\newcommand{\cintt}{{\ccode{int}}\xspace}
\newcommand{\cintttt}{{\ccode{int32\_t}}\xspace}
\newcommand{\cintsft}{{\ccode{int64\_t}}\xspace}

\newcommand{\uucap}{{\ccode{\_\_capability}}\xspace}

\newcommand{\SIGPROT}{{\ccode{SIGPROT}}\xspace}

\newcommand{\futurevariant}[1]{{\color{blue} #1}}
\newcommand{\morellovariant}[1]{{\color{red} #1}}

\newcommand{\note}[2]{{\color{blue}[ Note: #1 - #2]}}
\usepackage{xstring}
\IfSubStr*{\jobname}{final}{
  \renewcommand{\note}[2]{\relax\ifhmode\unskip\fi}
}{
  % show comments by default
}

\newcommand{\arnote}[1]{\note{#1}{Alex R.}}
\newcommand{\bdnote}[1]{\note{#1}{Brooks D.}}
\newcommand{\rwnote}[1]{\note{#1}{Robert W.}}
\newcommand{\amnote}[1]{\note{#1}{Alfredo M.}}
\newcommand{\psnote}[1]{\note{#1}{Peter S.}}
\newcommand{\pgnnote}[1]{\note{#1}{Peter N.}}
\newcommand{\jrtcnote}[1]{\note{#1}{Jess C.}}
\newcommand{\hmnote}[1]{\note{#1}{Hesham A.}}
\newcommand{\nwfnote}[1]{\note{#1}{nwf}}

% typeset C++ sensibly
% NB: \nolinebreak was only made robust upstream on 2019-08-20
\usepackage{relsize}
\newcommand*{\cpp}{\texorpdfstring{C\textsmaller[2]{\protect\nolinebreak[4]\hspace{-.05em}\raisebox{.45ex}{\textbf{++}}}}{C++}}
\newcommand*{\purecapCOrCpp}{CHERI C/\cpp{}}
\newcommand*{\CHERIhybridCOrCpp}{CHERI Hybrid C/\cpp{}}
\newcommand*{\hybridCOrCpp}{Hybrid C/\cpp{}}

\hyphenation{Free-BSD}
\hyphenation{Free-RTOS}
\hyphenation{Cheri-BSD}
\hyphenation{Cheri-Free-RTOS}
\hyphenation{Cheri-ABI}
\hyphenation{Web-Kit}
\hyphenation{Postgre-SQL}

\title{Review Draft: \\
  \CHERIhybridCOrCpp{} Programming Guide \\
  (DRAFT)}
\author{Robert~N.~M.~Watson$^*$,
    Alexander~Richardson$^*$,
    Jessica~Clarke$^*$, \\
    John Baldwin$^\ddagger$,
    David Chisnall$^\S$,
    Brooks Davis$^\dagger$,
    Simon W. Moore$^*$, \\
    Peter~G.~Neumann$^\dagger$
  \\
    \textbf{(others to be added)}
  \\
  \\
  $^*$University of Cambridge, $^\dagger$SRI International, \\
  $^\ddagger$Ararat River Consulting, LLC and $^\S$Microsoft Research}
%
%Alexander Richardson$^*$,
%  Brooks Davis$^\dagger$, \\
%  John Baldwin$^\ddagger$, David Chisnall$^\S$, Jessica Clarke$^*$,
%  Nathaniel Filardo$^*$, \\
%  Simon W. Moore$^*$,  Edward Napierala$^*$, Peter Sewell$^*$, and \\
%  Peter G. Neumann$^\dagger$ \\
%  \\

\begin{document}
\sloppy

%% CL tech-report format provides its own cover page.  Comment for final
%% version.
\maketitle

%% CL tech-report format requires page numbering to start at 3.  Uncomment for
%% final version.
%\setcounter{page}{3}
%%

%
% Keep Abstract in sync with the Introduction.
%
\newcommand{\abstracttext}{

This document is an introduction to the \CHERIhybridCOrCpp{} programming
language.
\hybridCOrCpp{} allows the selective use of CHERI capabilities from within an
otherwise unmodified, and Application Binary Interface (ABI)-compatible,
C/\cpp{}-language code base.
Its aim is to allow management of, and interoperation with, capability-enabled
code while using an integer rather than capability pointer implementation
internally.
Unlike in \purecapCOrCpp{}, \hybridCOrCpp{} defaults to an integer
implementation for pointers except where specifically annotated in the
program source code.
Due to the requirement for ABI compatibility, implied pointers within the
language runtime itself are also primarily implemented as integers rather than
capabilities.

\hybridCOrCpp{} primarily sees use in specialized low-level systems code that,
for compatibility or performance reasons, must use non-capability pointers.
Current use cases includes boot loaders, operating-system kernels, and
Inter-Process Communication (IPC) runtimes.
Potential future use cases include programs that have been formally verified
(which do not require dynamic memory safety) and language runtimes (which may
have high dynamic pointer memory access patterns making wider pointer sizes
unrealistic).

%Hybrid code is used in the CheriBSD kernel, and in the userspace run-time
%environment for hybrid processes to enable communication with pure-capability
%processes via co-process IPC.
Because the benefits of referential, spatial, and temporal memory safety are
unavailable to both the program and language runtime, care should be utilized,
and its use should be avoided where not strictly necessary.
}

\newcommand{\reviewwarning}{
\textbf{
As \hybridCOrCpp{} remains an area of active research and development, this
report is a request for review and comments rather than a specification.
}
\rwnote{This last sentence will go away in a final version.}
}

\begin{abstract}
\abstracttext

\reviewwarning
\end{abstract}

\newpage
\setcounter{tocdepth}{2}
\tableofcontents

\newpage

\section{Introduction}

%
% Keep Abstract in sync with the Introduction.
%
\abstracttext

This is a companion to the \textit{\purecapCOrCpp{} Programming
Guide}~\cite{UCAM-CL-TR-947}, and refers to that report rather than
replicating its contents.
Readers will benefit from having read that document prior to this one, as
many behaviors in \hybridCOrCpp{} are based on those in \purecapCOrCpp{}, or
will be contrasted with it in this guide.
The report \textit{Introduction to CHERI} technical
report~\cite{UCAM-CL-TR-941} will also provide background material for this
guide.

\section{Status of this document}

This document is a request for comments and feedback, and not a stable
specification.
This document currently describes three variants of \hybridCOrCpp{}:

\begin{enumerate}
\item \hybridCOrCpp{} as implemented in the CHERI Clang/LLVM implementation on
  CHERI-MIPS and CHERI-RISC-V.

  Unless otherwise indicated, all statements refer to this model.

\item \hybridCOrCpp{} as implemented in the CHERI Clang/LLVM implementation on
  Morello (which differs in small but important ways).

  Key differences are in \morellovariant{red text}.

\item Our current thinking on next directions for \hybridCOrCpp{}.

  Key differences are in \futurevariant{blue text}.
\end{enumerate}

\noindent
We have attempted to clearly comment on these behavioral divergences where
required.
It is our aim to achieve convergence of these approaches so that a single
\CHERIhybridCOrCpp{} can be used across all architectures, and best addresses
all use cases.
Feedback on this draft may be submitted via pull requests or the issue tracker
on our GitHub repository for the report:

\url{https://github.com/CTSRD-CHERI/cheri-hybrid-c-guide}

\section{Objective of \hybridCOrCpp{}}

\hybridCOrCpp{} aims to allow programs to be written to use conventional
integer pointers throughout their implementations, and yet also to interact
with capabilites via modest C-language extensions causing specifically
annotated pointers to be implemented using capabilities.
This is in contrast to \purecapCOrCpp{}, which implements all pointers as
capabilities by default, and whose aim is strong referential, spatial, and
temporal memory protection for C/\cpp{}.

\section{Definitions}

We are concerned with pointers arising from two parts of the C implementation:

\begin{description}
\item[Explicit pointers] are pointers visible in the program source.
  These include declared pointers taken to local, global, or thread-local
  variables, to functions, or pointers to returned heap allocations.
  In \hybridCOrCpp{}, these pointers will be implemented using capabilities
  only if specifically annotated.

\item[Implied pointers] are those used by the language runtime and generated
  code to manage the language implementation itself.
  This includes the stack pointer, program counter and return addresses, PLT
  entries, vtable pointers, and GOT/captable pointers.
  In \hybridCOrCpp{}, these pointers will be implemented using integers,
  although in some cases underlying data structures will be replicated to
  provide capability versions of them -- e.g., of the GOT.
\end{description}

\noindent
Pointers may be implemented using two underlaying architectural types:

\begin{description}
\item[Integer pointers] are pointers implemented as integers.
  Storage size and alignment will be the architectural address size (e.g.,
  64 bits on a 64-bit architecture in a 64-bit process environment).

  Generated code will utilize integer load and store instructions to access
  variables of these types, and dereference them using integer-relative
  instructions.

  Explicit pointers will be of this type by default.
  Implied pointers will be of this type if required by the existing ABI.

\item[Capability pointers] are pointers implemented using capabilities.
  Storage size and alignment will be the architectural capability size (e.g.,
  128 bits on a 64-bit architecture in a 64-bit process environment).

  Generated code will utilize capability load and store instructions to access
  variables of these types, and dereference them using capability-relative
  instructions.

  Explicit pointers will only be of this type if specifically annotated in the
  program source.
  Implied pointers may be of this type if it does not harm the ABI; some
  implied pointers may be replicated in order to allow both types to be used
  (e.g., by providing a GOT and a captable).
\end{description}

\section{Explicit pointers}

Explicit pointers can be implemented as capability pointers in several ways:

\begin{description}
\item[Pointers qualified with \uucap{}]
  To implement an explicit pointer as a capability in \hybridCOrCpp{}, the
  qualifier \uucap{} is used on a pointer type.
  For example, \ccode{char * \_\_capability c} declares a capability pointer
  to a \ccode{char}.
  Unqualified explicit pointers will be implemented as integer pointers.

\item[Other pointers that have no ABI impact]
  \futurevariant{There are opportunities to compile code using capability
  pointers, where using a different underlying architectural type has no
  impact on the ABI exposed (or potentially exposed) to other code.
  For example, unescaped pointers to local variables may be suitable for
  capability-pointer compilation.
  Other constraints may exist, such as the non-embedding of the pointer's size
  in escaped values.
  Further research is required to evaluate the viability and usefulness of
  this potential approach.}

\item[Other pointers that have a policy-contrained ABI impact]
  \futurevariant{There is also the opportunity to have a policy-determined
  impact on ABI, in which an explicit policy might allow compilation of
  larger portions of code in a manner that more substantively impacts ABI.
  Such policies might explicitly identify function types and data structures
  (e.g., public APIs) with public ABI guarantees while permitting substantial
  variation in other compiled code (e.g., private APIs).
  Further research is required to evaluate the viability and usefulness of
  this potential approach.}
\end{description}

\rwnote{Do we want a new item, ``Implied pointers that have a limited impact
  on ABI''?  E.g., to capture the CRA case?}

\section{Implied pointers}

We consider three cases:

\begin{description}
\item[Implied pointers critical to the ABI]
  Wherever the ABI dictates that implied pointers must be integer pointers,
  that will be maintained by \hybridCOrCpp{} code generation and in the
  language runtime.
  For example, the hybrid ABI requires that the stack pointer be an integer
  pointer.

\item[Implied pointers invisible to the ABI]
  In some cases, implied pointers may be implemented as capability pointers
  without impacting the ABI.

  {\color{blue} For example, hybrid code could use a capability return address
  rather than an integer return address to provide pointer provenance validity
  for the return address, even if not tight bounds, as the return address is
  not part of the ABI to other functions.}
  \jrtcnote{\cfunc{\_\_builtin\_return\_address} does leak these implied
  pointers to some code, and it has implications for things like libunwind, so
  it does affect the ABI. Also the kernel needs to know to put a capability in
  CRA in order for signal handlers to be able to return to \cfunc{sigcode}.
  There's a lot of subtlety here that needs to be captured.}
  \rwnote{I'd been pondering whether the ABI might allow us to use a return
  capability, but in which unwind/etc only looked at the lower 64 bits...  And
  I suppose the builtin could be polymorphic.  But signals are indeed a messy
  issue.
  Is there a better example we could give?}

\item[Implied pointers that can be replicated as integer and capability
  pointers]
  In other cases, implied pointers may be replicated, with a full set of
  integer pointer variants provided for the existing ABI, but additional
  capability pointer variants provided for hybrid code.

  \futurevariant{For example, a separate captable could be provided,
  replicating the set of entries in the existing GOT, to allow capability
  pointers taken to global variables to have desired bounds and permissions.}

  \morellovariant{In the Morello ABI, capability pointers taken to globals
  pick up bounds and other metadata from constant pools of capabilities,
  effectively small per-function captables manually created by the compiler.}
\end{description}

\section{\& address-of operator}

\rwnote{TODO: whether it returns an integer pointer or is polymorphic.  If not
  polymorphic, what we recommend.}

\section{Limitations}

This is a relatively weak integration of CHERI support with the language and
run-time environment offering limited memory protection only in very specific
circumstances.
Except where Application Programming Interfaces (APIs) have been extended to
support explicit capability arguments or return values, pointers will not
be protected by capability integrity, pointer provenance validity, bounds,
permissions, or monotonicity.
For example, \cfunc{malloc} will not return pointers as capabilities with
bounds set, and also may not align or pad allocations such that they can be
bounded imprecisely without loss of spatial protection relative to adjacent
allocations.
Further, the control-flow and other data structures used by C and the C
runtime themselves do not use capabilities, and so some of the resilience to
exploitation found in \purecapCOrCpp{}, such as return addresses and stack
pointers implemented using capabilities, are not found in \hybridCOrCpp{}.
Specific limitations by protection type are:

\subsubsection{Incomplete referential, spatial, and temporal safety}

\begin{itemize}
\item Integer pointers, returned by various memory allocators by default, do
  not implement capability protections including tag, bounds, and permissions.
  As a result, integer pointers suffer from a lack of provenance validity and
  spatial safety.

\item Whenever a capability pointer type is cast to an integer pointer type,
  its capability metadata, including tag, bounds, and permissions, are lost.
  The resulting integer pointer will be dereferenced relative to the Default
  Data Capability (DDC), and uses those bounds and permissions, which may be
  substantial, and provenance validity is not implemented.

\item Whenever an integer pointer type is cast to a capability pointer type,
  the compiler will derive the new capability from DDC without refining its
  bounds or permissions, offering provenance validity but not privilege
  minimization.

\item Both explicit function pointers and implied pointers such as return
  addresses and PLT entries are implemented as integer pointers, and therefore
  lack provenance validity, bounds, and permissions.

\item Other data structures implemented by the language runtime and compiler,
  such as the stack, are also implemented using integer pointers that do not
  implement provenance validity, bounds, or permissions.

\item CHERI temporal safety relies on capability implementation of pointers,
  so that the tag, bounds, and permissions can be utilized to detect stale
  pointers to quarantined memory.
  As many pointers in a hybrid program are implemented using integers,
  temporal safety is unable to precisely find all pointers or arrange for
  their suitably atomic replacement.
\end{itemize}

As a result of these limitations, privilege minimization in the language
runtime, control-flow mechanisms, and user data types is largely unimplementd.
Protections are only refined and enforced for programmer-selected types, which
can offer substantial value in specific scenarios, but is not a source of
general robustness for the C and C++ implementations.
All privilege reductions are programmer-implemented through explicit calls to
narrow bounds and permissions.

\subsection{Use cases}

Despite these limitations, \hybridCOrCpp{} is an invaluable tool in specific
programming environments; for example:

\begin{description}
\item[Hybrid CheriBSD kernel]
  The \hybridCOrCpp{} compiled CheriBSD kernel is almost entirely
  conventional C/\cpp{} implemented using integer pointers, except for its
  handling of system-call arguments and capability state, which is manually
  annotated.

\item{Co-process IPC libraries in hybrid processes}

\item XXX More?

\end{description}

\subsection{Origins of bounds and permissions}

Pointers implemented by capabilities by definition carry capability metadata:
tag, bounds, permissions, and so on.




\section{Casts between integer and capability pointers}


\rwnote{DDC}

\subsection{Casts from integer to capability pointers}

\subsection{Casts from capability to integer pointers}

\section{Recommended use of C-language types}
\label{sec:recommended-c-types}

\rwnote{This needs updating for hybrid use.}

As confusion frequently arises about the most appropriate types to use for
integers, pointers, and pointer-related values, we make the following
recommendations:

\begin{description}
\item[\cintt, \cintttt, \clongt, \cintsft,
  \ldots{}] These pure integer types should be used to hold integer values
  that will never be cast to a pointer type without first combining them with
  another pointer value -- e.g., by using them as an array offset.
  Most integers in a C/\cpp{}-language program will be of these types.

\item[\ptraddrt] This is a new integer type introduced by CHERI C and should be used to hold
  addresses.
  \ptraddrt should not be directly cast to a pointer type for
  dereference; instead, it must be combined with an existing valid capability
  to the address space to generate a dereferenceable pointer.
  Typically, this is done using the \ccode{cheri\_address\_set(c, x)} function.

\item[\sizet, \ssizet] These integer types should be used
  to hold the unsigned or signed lengths of regions of address space.
  \arnote{\sizet not necessary the same as unsigned \ptrdifft.}

\item[\ptrdifft] This integer type describes the difference of indices
  between two pointers to elements of the same array, and should not be used for
any other purpose.
  It can be added to a pointer to obtain a new pointer, but the result will
  be dereferenceable only if the address lies within the bounds of the
  pointer from which it was derived.

  \note{Isn't that last sentence true of any combination?}{nwf}

  Less standards-compliant code sometimes uses \ptrdifft when the
  programmer more likely meant \cintptrt or (less commonly)
  \sizet.
  When porting code, it is worthwhile to audit use of \ptrdifft.

  \note{Should we recommend that \sizet be used to hold lengths of
  allocations and \ptrdifft be used to talk about spans of
  address space (e.g., the offsets between two subobjects of an allocation)?  I feel
  like the recommendations here are not as concrete as I'd like.}{nwf}

\item[\cintptrt, \cuintptrt] These integer types should be
  used to hold values that may be valid pointers if cast back to a pointer
  type.
  When an \cintptrt is assigned an integer value -- e.g., due to
  constant initialization to an integer in the source -- and the result is
  cast to a pointer type, the pointer will be invalid and hence
  non-dereferenceable.
  These types will be used in two cases: (1) Where there is uncertainty as to
  whether the value to be held will be an integer or a pointer -- e.g., for an
  opaque argument to a callback function; or (2) Where it is more convenient
  to place a pointer value in an integer type for the purposes of arithmetic
  (which takes place on the capability's address and in units of bytes, as if
  the pointer had been cast to \texttt{char *}).

  The observable, integer range of a \cuintptrt is the same as
  that of a \ptraddrt (or \ptrdifft for \cintptrt), despite the increased \emph{alignment} and \emph{storage} requirements.

\item[\ccode{intmax\_t}, \ccode{uintmax\_t}] According to the C standard\arnote{7.20.1.5 Greatest-width integer types}, these integer types should be \enquote{capable of representing any value of any (unsigned) integer type}.
  In \purecapCOrCpp{}, they are not provenance-carrying and can represent the integer \emph{range} of \cuintptrt/\cintptrt, but not the capability metadata or tag bit.
  As the observable value of \cuintptrt/\cintptrt is the pointer address range, we believe this choice to be compatible with the C standard.

  Additionally, due to ABI constraints, it would be extremely difficult to change the width of these types from 64 to 129 bits.
  This is also true for other architectures such as x86: despite Clang and GCC supporting an \ccode{\_\_int128} type, \ccode{intmax\_t} remains 64 bits wide.

  We generally do not recommend use of these types in \purecapCOrCpp{}.
  However, the types may be useful in \cfunc{printf} calls (using the \ccode{\%j} format string width modifier) as the \pathname{inttypes.h} \ccode{PRI*} macros can be rather verbose.


\item[\maxalignt] This type is defined in C as \enquote{an object type whose alignment is the greatest fundamental alignment} \arnote{C2x \S{}7.19.2} and this includes capability types for \purecapCOrCpp{}.
% and in \cpp{} as a \enquote{type whose alignment requirement is at least as great as that of every scalar type}\arnote{C++17 \S{}21.2.4p5}
We found that some custom allocators use \ccode{sizeof(long double)} or \ccode{sizeof(uint64\_t)} to align their return values.
While this appears to work on most architectures, in \purecapCOrCpp{} this must be changed to \ccode{alignof(\maxalignt)}\kern-2pt.%
%
\footnote{%
It is important to use \ccode{alignof} instead of \ccode{sizeof} since many
common implementations, such as GCC and FreeBSD, define \maxalignt as a
\ccode{struct} and not a \ccode{union}.}

\item[\ccharstar, \ldots{}] These pointer types are suitable for
  dereference, but in general \psnote{that ``in general'' makes me wonder about the exceptions?}
  \arnote{The only exception I can think of is requiring \cvoidstar due to bad API design (callback parameters, etc).}  should not be cast to or from arbitrary integer
  values.
  Valid pointers are always derived from other valid pointers (including those cast to \cintptrt or \cuintptrt), and cannot be
  constructed using arbitrary integer arithmetic.
\end{description}

It is important to note that \cuintptrt is no longer the same size as
\sizet. This difference may require making some changes to
existing code to use the correct type depending on whether the variable
needs to be able store a pointer type. In cases where this is not obvious
(such as for a callback argument), we recommend the use of \cuintptrt.
This ensures that provenance is maintained.

\pgnnote{The above section begs questions relating to what is the
  responsibility of programmers and what can be aided or managed by
  compilers.  Ideally, the latter would be preferable to requiring
  programmers to understand things are possibly beyond their so-called
  experience.}

\section{The CHERI hybrid process environment}

\section{Further reading}
\label{sec:further_reading}

\rwnote{Update: The two real references are likely the CHERI C/C++ guide and
the Introduction to CHERI report}

The primary reference for the CHERI Instruction-Set Architecture (ISA) is the
ISA specification; at the time of writing, the most recent version is CHERI
ISAv7~\cite{UCAM-CL-TR-927}:

\smallskip
\noindent
\url{https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-927.pdf}
\smallskip

\noindent
Our technical report, \textit{An Introduction to CHERI}, provides a high-level
overview of the CHERI architecture, ISA modeling, hardware implementations,
and software stack~\cite{UCAM-CL-TR-941}:

\smallskip
\noindent
\url{https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-941.pdf}
\smallskip

\section{Acknowledgements}

\rwnote{Update feedback acknowledgments here.}

\rwnote{Add authors of CHERI C/C++ Programming Guide who don't end up being
  authors on this document.}

We gratefully acknowledge the helpful feedback from our colleagues, including
Hesham Almatary,
Ruben Ayrapetyan, Silviu Baranga, Jacob Bramley, Rod Chapman, Paul Gotch, Al Grant,
Brett Gutstein, Alfredo Mazzinghi, Alan Mycroft, and Lee Smith.
This work was supported by the Defense Advanced Research Projects Agency (DARPA) and the Air Force Research Laboratory (AFRL), under contracts
FA8750-10-C-0237 (``CTSRD'') and HR0011-18-C-0016 (``ECATS'').
The views, opinions, and/or findings contained in this report are those of the authors and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.
This work was supported in part by the Innovate UK project Digital Security by
Design (DSbD) Technology Platform Prototype, 105694.
This project has received funding from the European Research Council
(ERC) under the European Unionâs Horizon 2020 research and innovation programme (grant agreement No 789108), ERC Advanced Grant ELVER.
We also acknowledge the EPSRC REMS Programme Grant (EP/K008528/1), Arm Limited,
HP Enterprise, and Google, Inc.
Approved for Public Release, Distribution Unlimited.

\printbibliography

\end{document}
