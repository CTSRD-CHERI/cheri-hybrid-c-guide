\documentclass[12pt,twoside,openright,a4paper]{article}
%\documentclass[12pt,twoside,openright,usletter]{article}
% !TeX spellcheck = en_US
%\documentclass[11pt]{article}
% UK date format in bibliography:
\usepackage[british]{babel}
\usepackage[inner=25mm,outer=25mm,top=20mm,bottom=20mm]{geometry}

%\usepackage[UKenglish]{isodate}%UK date endian
\usepackage[headings]{fullpage}
\usepackage[hidelinks]{hyperref}

% Bibliography:
\usepackage[utf8]{inputenc}
\usepackage{csquotes,xpatch}% recommended
% list up to 99 names instead of the default 3
\usepackage[backend=biber,bibencoding=utf8,style=numeric,maxnames=99,backref=false,sortcites,datamodel=thesis]{biblatex}
\addbibresource{cheri.bib}
\AtEveryBibitem{%
% Don't print ISBN,issn, or URL dates
\clearfield{issn}%
\clearfield{isbn}%
\clearfield{urldate}%
\clearfield{urlyear}%
}

\usepackage{bytefield}
\usepackage{color}
\usepackage[scaled=0.8]{DejaVuSansMono}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{mdframed} % To avoid linebreaks in lstlistings
\lstnewenvironment{clisting}[1][]{\endgraf\noindent\minipage{\linewidth}\lstset{language={C},breaklines=true,frame=L,#1}}{\endminipage\endgraf}
\lstnewenvironment{compilerwarning}[1][]{\endgraf\noindent\minipage{\linewidth}\lstset{language={},breaklines=true,basicstyle=\scriptsize\ttfamily\bfseries,frame=L,#1}}{\endminipage\endgraf}

\usepackage{subcaption}
\usepackage{times}
\usepackage{url}
\usepackage[svgnames]{xcolor}
\definecolor{lightgray}{gray}{0.8}
\usepackage{xspace}
\usepackage{xfrac}

\usepackage[nameinlink,noabbrev,capitalise]{cleveref}

% drawing over lstlistings (code stolen from nwf)
\usepackage{tikz}
   \usetikzlibrary{decorations.pathreplacing}
   \usetikzlibrary{fit}
   \usetikzlibrary{tikzmark}
   \usetikzlibrary{calc}
   \usetikzlibrary{patterns}
\newcommand*{\vcpgfmark}[1]{\ensuremath{\vcenter{\hbox{\pgfmark{#1}}}}}
% GBP symbol should be safe since it's easy to enter (at least on a UK keyboard) and won't be in any valid lstlistings
\lstset{escapechar=£} % Note: ensure this doesn't occur in any of the code
\newcommand{\TikzListingHighlight}[3][]{\tikz[overlay,remember picture]{\draw[\ifstrempty{#1}{yellow}{#1}, line width=10pt,opacity=0.3](#2) -- (#3);}}
\newcommand*{\TikzListingHighlightStartEnd}[2][]{\tikz[overlay,remember picture]{\draw[\ifstrempty{#1}{yellow}{#1}, line width=10pt,opacity=0.3](pic cs:Start#2) -- (pic cs:End#2);}}


\renewcommand{\UrlFont}{\ttfamily\small}

\newcommand{\baselineboxformatting}[1]{%
  % Measure size of contents
  \sbox0{#1}%
  % Use the difference between the contents' height and the bitbox's height,
  % clamped to [-.44\baselineskip, 0], as our minimum depth.
  \setlength{\skip0}{\ht0 - \height}%
  \ifdim\skip0>0pt%
    \setlength{\skip0}{0}%
  \else%
    \ifdim\skip0<-.44\baselineskip%
      \setlength{\skip0}{-.44\baselineskip}%
    \fi%
  \fi%
  \centering\rule[\skip0]{0pt}{\height}#1}
\bytefieldsetup{boxformatting=\baselineboxformatting}

\lstset{basicstyle=\footnotesize\ttfamily}
%\newcommand{\ccode}[1]{\lstinline[language={C}]{#1}}
%\newcommand{\cxxcode}[1]{\lstinline[language={C++}]{#1}}
\newcommand{\ccode}[1]{{\small\ttfamily{#1}}}
\newcommand{\cxxcode}[1]{{\ccode{#1}}}
\newcommand{\cconst}[1]{{\ccode{#1}}}
\newcommand{\cfunc}[1]{{\ccode{#1()}}}
\newcommand{\cvar}[1]{{\ccode{#1}}}
\newcommand{\pathname}[1]{{\ccode{#1}}}
\newcommand{\commandline}[1]{{\ccode{#1}}}

\newcommand{\ptrdifft}{{\ccode{ptrdiff\_t}}\xspace}
\newcommand{\maxalignt}{{\ccode{max\_align\_t}}\xspace}
\newcommand{\sizet}{{\ccode{size\_t}}\xspace}
\newcommand{\ssizet}{{\ccode{ssize\_t}}\xspace}
\newcommand{\ptraddrt}{{\ccode{ptraddr\_t}}\xspace}
\newcommand{\cuintptrt}{{\ccode{uintptr\_t}}\xspace}
\newcommand{\cintptrt}{{\ccode{intptr\_t}}\xspace}
\newcommand{\ccharstar}{{\ccode{char *}}\xspace}
\newcommand{\cvoidstar}{{\ccode{void *}}\xspace}
\newcommand{\clongt}{{\ccode{long}}\xspace}
\newcommand{\cintt}{{\ccode{int}}\xspace}
\newcommand{\cintttt}{{\ccode{int32\_t}}\xspace}
\newcommand{\cintsft}{{\ccode{int64\_t}}\xspace}
\newcommand{\cintcapt}{{\ccode{intcap\_t}}\xspace}

\newcommand{\uucap}{{\ccode{\_\_capability}}\xspace}

\newcommand{\SIGPROT}{{\ccode{SIGPROT}}\xspace}

\newcommand{\futurevariant}[1]{{\color{blue} #1}}
\newcommand{\morellovariant}[1]{{\color{red} #1}}

\newcommand{\note}[2]{{\color{blue}[ Note: #1 - #2]}}
\usepackage{xstring}
\IfSubStr*{\jobname}{final}{
  \renewcommand{\note}[2]{\relax\ifhmode\unskip\fi}
}{
  % show comments by default
}

\newcommand{\arnote}[1]{\note{#1}{Alex R.}}
\newcommand{\bdnote}[1]{\note{#1}{Brooks D.}}
\newcommand{\rwnote}[1]{\note{#1}{Robert W.}}
\newcommand{\amnote}[1]{\note{#1}{Alfredo M.}}
\newcommand{\psnote}[1]{\note{#1}{Peter S.}}
\newcommand{\pgnnote}[1]{\note{#1}{Peter N.}}
\newcommand{\jrtcnote}[1]{\note{#1}{Jess C.}}
\newcommand{\hmnote}[1]{\note{#1}{Hesham A.}}
\newcommand{\nwfnote}[1]{\note{#1}{nwf}}

% typeset C++ sensibly
% NB: \nolinebreak was only made robust upstream on 2019-08-20
\usepackage{relsize}
\newcommand*{\cpp}{\texorpdfstring{C\textsmaller[2]{\protect\nolinebreak[4]\hspace{-.05em}\raisebox{.45ex}{\textbf{++}}}}{C++}}
\newcommand*{\COrCpp}{C/\cpp{}}
\newcommand*{\purecapCOrCpp}{CHERI \COrCpp{}}
\newcommand*{\CHERIhybridCOrCpp}{CHERI Hybrid \COrCpp{}}
\newcommand*{\hybridCOrCpp}{Hybrid \COrCpp{}}

\hyphenation{Free-BSD}
\hyphenation{Free-RTOS}
\hyphenation{Cheri-BSD}
\hyphenation{Cheri-Free-RTOS}
\hyphenation{Cheri-ABI}
\hyphenation{Web-Kit}
\hyphenation{Postgre-SQL}

\title{Review Draft: \\
  \CHERIhybridCOrCpp{} Programming Guide \\
  (DRAFT)}
\author{Robert~N.~M.~Watson$^*$,
    Alexander~Richardson$^*$,
    Jessica~Clarke$^*$,
    Brooks Davis$^\dagger$, \\
    John Baldwin$^\ddagger$,
    David Chisnall$^\S$,
    Nathaniel Filardo$^\S$,
    Simon W. Moore$^*$, \\
    Edward Napierala$^*$,
    Peter Sewell$^*$,
    Peter~G.~Neumann$^\dagger$
  \\
    \textbf{(others to be added)}
  \\
  \\
  $^*$University of Cambridge, $^\dagger$SRI International, \\
  $^\ddagger$Ararat River Consulting, LLC and $^\S$Microsoft Research}
%
%Alexander Richardson$^*$,
%  Brooks Davis$^\dagger$, \\
%  John Baldwin$^\ddagger$, David Chisnall$^\S$, Jessica Clarke$^*$,
%  Nathaniel Filardo$^*$, \\
%  Simon W. Moore$^*$,  Edward Napierala$^*$, Peter Sewell$^*$, and \\
%  Peter G. Neumann$^\dagger$ \\
%  \\

\begin{document}
\sloppy

%% CL tech-report format provides its own cover page.  Comment for final
%% version.
\maketitle

%% CL tech-report format requires page numbering to start at 3.  Uncomment for
%% final version.
%\setcounter{page}{3}
%%

%
% Keep Abstract in sync with the Introduction.
%
\newcommand{\abstracttext}{

This document is an introduction to the \CHERIhybridCOrCpp{} programming
language.
\hybridCOrCpp{} allows the selective use of CHERI capabilities from within an
otherwise unmodified, and Application Binary Interface (ABI)-compatible,
C/\cpp{}-language code base.
Its aim is to allow management of, and interoperation with, capability-enabled
code while using an integer rather than capability pointer implementation
internally.
Unlike in \purecapCOrCpp{}, \hybridCOrCpp{} defaults to an integer
implementation for pointers except where specifically annotated in the
program source code.
Due to the requirement for ABI compatibility, implied pointers within the
language runtime itself are also primarily implemented as integers rather than
capabilities.

\hybridCOrCpp{} primarily sees use in specialized low-level systems code that,
for compatibility or performance reasons, must use non-capability pointers.
Current use cases includes boot loaders, operating-system kernels, and
Inter-Process Communication (IPC) runtimes.
Potential future use cases include programs that have been formally verified
(which do not require dynamic memory safety) and language runtimes (which may
have high dynamic pointer memory access patterns making wider pointer sizes
unrealistic).

\nwfnote{Is that really about the \emph{access} pattern or more the
\emph{density} of pointers in memory?  I would imagine that people usually
object to the increased footprint before they object to the increased DRAM
traffic implied by moving larger pointers around?}

\nwfnote{Do you want to call out partially adapted compartmentalized programs
(possibly inclusive of programs with their own runtime systems; one could
imagine enriching JS to have a ForeignCapability type, e.g.) as another
possible example where being able to exchange capabilities might be useful
despite possibly having a non-NULL DDC?}

%Hybrid code is used in the CheriBSD kernel, and in the userspace run-time
%environment for hybrid processes to enable communication with pure-capability
%processes via co-process IPC.
Because the benefits of referential, spatial, and temporal memory safety are
unavailable to both the program and language runtime, care should be utilized,
and its use should be avoided where not strictly necessary.

\nwfnote{``its'' is not very clear (and might plausibly, syntactically, refer
to ``care''); maybe ``\hybridCOrCpp{} should be used only where strictly
necessary''?}
}

\newcommand{\reviewwarning}{
\textbf{
As \hybridCOrCpp{} remains an area of active research and development, this
report is a request for review and comments rather than a specification.
}
\rwnote{This last sentence will go away in a final version.}
}

\begin{abstract}
\abstracttext

\reviewwarning
\end{abstract}

\newpage
\setcounter{tocdepth}{2}
\tableofcontents

\newpage

\section{Introduction}

%
% Keep Abstract in sync with the Introduction.
%
\abstracttext

This is a companion to the \textit{\purecapCOrCpp{} Programming
Guide}~\cite{UCAM-CL-TR-947}, and refers to that report rather than
replicating its contents.
Readers will benefit from having read that document prior to this one, as
many behaviors in \hybridCOrCpp{} are based on those in \purecapCOrCpp{}, or
will be contrasted with it in this guide.
The \textit{Introduction to CHERI} technical
report~\cite{UCAM-CL-TR-941} also provides background material for this
guide.

\subsection{Document structure}

This report describes:

\begin{itemize}
\item The objectives and potential use cases for \CHERIhybridCOrCpp{};
\item How \hybridCOrCpp{} interacts with explicit pointers in program source
  code, as well as implied pointers in the language runtime;
\item The impact of \hybridCOrCpp{} on C-language types, casts and the address-of operator
  (\ccode{\&});
\item A number of inherent and practical implications to \hybridCOrCpp{}; and
\item Further reading relating to CHERI and \COrCpp{} on CHERI.
\end{itemize}

\subsection{Status of this document}

This document is a request for comments and feedback, and not a stable
specification.
This document currently describes three variants of \hybridCOrCpp{}:

\begin{enumerate}
\item \hybridCOrCpp{} as implemented in the CHERI Clang/LLVM implementation on
  CHERI-MIPS and CHERI-RISC-V.

  Unless otherwise indicated, all statements refer to this model.

\item \hybridCOrCpp{} as implemented in the CHERI Clang/LLVM implementation on
  Morello (which differs in small but important ways).

  Key differences are in \morellovariant{red text}.

\item Our current thinking on next directions for \hybridCOrCpp{}.

  Key differences are in \futurevariant{blue text}.
\end{enumerate}

\noindent
We have attempted to clearly comment on these behavioral divergences where
required.
It is our aim to achieve convergence of these approaches so that a single
\CHERIhybridCOrCpp{} can be used across all architectures, and best addresses
all use cases.
Feedback on this draft may be submitted via pull requests or the issue tracker
on our GitHub repository for the report:

\smallskip

\url{https://github.com/CTSRD-CHERI/cheri-hybrid-c-guide}

\section{Objective and use cases for \hybridCOrCpp{}}

The aim of \hybridCOrCpp{} is to allow programs to be written using
conventional integer pointers throughout their implementations, and yet also
to interact with capabilites via modest C-language extensions causing
specifically annotated pointers to be implemented using capabilities.
This is in contrast to \purecapCOrCpp{}, which implements all pointers as
capabilities by default, and whose aim is strong referential, spatial, and
temporal memory protection for C/\cpp{}.
While \hybridCOrCpp{} is unable to provide strong referential, spatial, or
temporal safety in most use cases, it allows conventional
integer-pointer-based code to interact usefully with capabilities in a number
of specific use cases.

\subsection{Hybrid CheriBSD kernel}

CheriBSD implements two kernel variants: a \hybridCOrCpp{} compilation, and a
\purecapCOrCpp{} variant.
The \hybridCOrCpp{} compilation aims to support a CHERI-enabled userspace
without substantive changes to kernel-internal protection.
In the latter, the aim is to also use CHERI memory protection within the
kernel.
Both kernel variants support hybrid and pure-capability (CheriABI) userspace
process environments.

The \hybridCOrCpp{}-compiled CheriBSD kernel is almost entirely implemented
in conventional \COrCpp{} using integer pointers, except for its handling of
system-call arguments and capability state, which are manually annotated.
Capability pointers are used in the kernel for three reasons:

\begin{enumerate}
\item To manage the dynamic state of capability-enabled kernel and user
  threads as part of context management and exception handling;

\item In the implementation of tag-enabled virtual-memory abstractions, such
  as copy-on-write propagating tag bits; and

\item To handle pointer-type userspace system-call arguments as capabilities
  rather than integer pointers, both to enable capability-based behaviors
  (such as having opaque pointer types used in POSIX asynchronous I/O be able
  to hold capabilities), and to prevent confused deputy attacks (such as might
  occur if an omnipotent kernel ignored userspace-originated bounds on stack
  or heap allocations).
\end{enumerate}

In order to unify system-call handling, user pointers originating in hybrid
ABI processes are converted into capability pointers at the system-call
boundary.
This leads to coarse-grained bounds, but, for example, permit user pointers to
be used only in accessing userspace memory.
For pure-capability (CheriABI) processes, user pointer types originate as
capabilities, and are simply propagated as necessary.
This approach is moderately disruptive of the kernel source code: While there
are few structural changes, user-originated pointers are manually annotated
with \uucap{} throughout.

\subsection{The CheriBSD hybrid process environment}

In the usermode portion of the CheriBSD hybrid ABI process environment, some
system libraries are extended with modest capability annotations to support
capability use.
For example, \ccode{memcpy()} and \ccode{sort()} must propagate tags rather
than perform byte-wise copies, in order to preserve pointers embedded in data
structures across memory copies.
In general, support for capabilities is weak within the runtime: We have not
updated \ccode{malloc()} to provide a \ccode{malloc\_c()} variant returning
capabilities, implementing suitable capability alignment, or implementing
temporal memory safety.
System calls are also not generally extended to support capability arguments
or return values, limiting the useful origins for capabilities other than as
derived from the Default Data Capability (DDC) or Program Counter Capability
(PCC).

\subsection{Co-process IPC libraries in hybrid processes}

We have been developing a CHERI-based compartmentalization model called
\textit{co-located processes} (or \textit{co-processes} for short).
In this model, a set of UNIX processes are colocated within a single shared
virtual address space, but kept separate by virtue of CHERI capabilities:
processes only ever receive capabilities to their own individual mappings.

Co-process Inter-Process Communication (IPC) relies on bridging those
processes by allowing a limited set of capabilities to be shared between those
processes.
In this approach, hybrid capability-extended IPC libraries would have access
to the memory of remote processes using CHERI capabilities, but the majority
of code in a hybrid process would not have that direct access.
Depending on performance and compatibility objectives, knowledge of
co-processes could be restricted to low-level IPC libraries, or be propagated
higher in the IPC stack, reducing the need for memory copying.

This is an area where our research is ongoing, but access to high-performance
CHERI IPC with only limited recompilation and extension to existing software
packages is a potentially promising area.

\subsection{Hybrid language runtimes}

Managed language runtimes are a point of particular performance concern with
CHERI, as they often have a high density of pointers in their dynamic memory
access patterns.
This makes them potentially more sensitive to CHERI's pointer-size growth in
pure-capability compilation.
On the other hand, CHERI capabilities offer the opportunity to improve
robustness and performance by allowing selective use of capabilities to
protect key types and provide hardware assistance for bounds checking.
On the whole, our recommendation has been to consider compiling language
runtimes as pure-capability code making selective use of integer pointers
(e.g., into language-specific heaps reached via capabilities), but
another approach would be to compile them as hybrid code making selective use
of capabilities -- e.g., when accessing bounded arrays in the heap.

\section{Pointer implementation}

Pointers may be implemented using two underlaying architectural types:

\begin{description}
\item[Integer pointers] are pointers implemented as integers.
  Storage size and alignment will be the architectural address size (e.g.,
  64 bits on a 64-bit architecture in a 64-bit process environment).

  Generated code will utilize integer load and store instructions to access
  variables of these types, and dereference them using integer-relative
  instructions.

  Explicit pointers will be of this type by default.
  Implied pointers will be of this type if required by the existing ABI.

\item[Capability pointers] are pointers implemented using capabilities.
  Storage size and alignment will be the architectural capability size (e.g.,
  128 bits on a 64-bit architecture in a 64-bit process environment).

  Generated code will utilize capability load and store instructions to access
  variables of these types, and dereference them using capability-relative
  instructions.

  Explicit pointers will only be of this type if specifically annotated in the
  program source.
  Implied pointers may be of this type if it does not harm the ABI; some
  implied pointers may be replicated in order to allow both types to be used
  (e.g., by providing a GOT and a captable).
\end{description}

In the following sections, we consider the implementation of pointers in
C/\cpp{} source code and also the language runtime.

\subsection{Pointers in source code, code generation, and the runtime}

We are concerned with pointers arising from two parts of the C implementation:

\begin{description}
\item[Explicit pointers] are pointers visible in the program source.
  These include declared pointers taken to local, global, or thread-local
  variables, to functions, or pointers to returned heap allocations.
  In \hybridCOrCpp{}, these pointers will be implemented using capabilities
  only if specifically annotated.

\item[Implied pointers] are those used by the language runtime and generated
  code to manage the language implementation itself.
  This includes the stack pointer, program counter and return addresses, PLT
  entries, vtable pointers, and GOT/captable pointers.
  In \hybridCOrCpp{}, these pointers will be implemented using integers,
  although in some cases underlying data structures will be replicated to
  provide capability versions of them -- e.g., of the GOT.
\end{description}

\subsection{Explicit pointers}

Explicit pointers can be implemented as capability pointers in several ways:

\begin{description}
\item[Pointers qualified with \uucap{}]
  To implement an explicit pointer as a capability in \hybridCOrCpp{}, the
  qualifier \uucap{} is used on a pointer type.
  For example, \ccode{char * \_\_capability c} declares a capability pointer
  to a \ccode{char}.
  Unqualified explicit pointers will be implemented as integer pointers.

\item[Other pointers that have no ABI impact]
  \futurevariant{There are opportunities to compile code using capability
  pointers, where using a different underlying architectural type has no
  impact on the ABI exposed (or potentially exposed) to other code.
  For example, unescaped pointers to local variables may be suitable for
  capability-pointer compilation.
  Other constraints may exist, such as the non-embedding of the pointer's size
  in escaped values.
  Further research is required to evaluate the viability and usefulness of
  this potential approach.}

\item[Other pointers that have a policy-contrained ABI impact]
  \futurevariant{There is also the opportunity to have a policy-determined
  impact on ABI, in which an explicit policy might allow compilation of
  larger portions of code in a manner that more substantively impacts ABI.
  Such policies might explicitly identify function types and data structures
  (e.g., public APIs) with public ABI guarantees while permitting substantial
  variation in other compiled code (e.g., private APIs).
  Further research is required to evaluate the viability and usefulness of
  this potential approach.}
\end{description}

\nwfnote{Is that ``policy-constrained'' or ``policy-contained'' or something else?}

\rwnote{Do we want a new item, ``Implied pointers that have a limited impact
  on ABI''?  E.g., to capture the CRA case?}

\rwnote{Have we gotten too researchy here, and we should just stick to the
  simple story that only those tagged with \uucap{} matter.
  I seem to recall that we also have a pragma for managing the default
  interpretation to be used in header files shared between interpretations...}

\subsection{Implied pointers}

We consider three cases:

\begin{description}
\item[Implied pointers critical to the ABI]
  Wherever the ABI dictates that implied pointers must be integer pointers,
  that will be maintained by \hybridCOrCpp{} code generation and in the
  language runtime.
  For example, the hybrid ABI requires that the stack pointer be an integer
  pointer.

\item[Implied pointers invisible to the ABI]
  In some cases, implied pointers may be implemented as capability pointers
  without impacting the ABI.

  {\color{blue} For example, hybrid code could use a capability return address
  rather than an integer return address to provide pointer provenance validity
  for the return address, even if not tight bounds, as the return address is
  not part of the ABI to other functions.}
  \jrtcnote{\cfunc{\_\_builtin\_return\_address} does leak these implied
  pointers to some code, and it has implications for things like libunwind, so
  it does affect the ABI. Also the kernel needs to know to put a capability in
  CRA in order for signal handlers to be able to return to \cfunc{sigcode}.
  There's a lot of subtlety here that needs to be captured.}
  \rwnote{I'd been pondering whether the ABI might allow us to use a return
  capability, but in which unwind/etc only looked at the lower 64 bits...  And
  I suppose the builtin could be polymorphic.  But signals are indeed a messy
  issue.
  Is there a better example we could give?}

\item[Implied pointers that can be replicated as integer and capability
  pointers]
  In other cases, implied pointers may be replicated, with a full set of
  integer pointer variants provided for the existing ABI, but additional
  capability pointer variants provided for hybrid code.

  \futurevariant{For example, a separate captable could be provided,
  replicating the set of entries in the existing GOT, to allow capability
  pointers taken to global variables to have desired bounds and permissions.}

  \morellovariant{In the Morello ABI, capability pointers taken to globals
  pick up bounds and other metadata from constant pools of capabilities,
  effectively small per-function captables manually created by the compiler.}
\end{description}

\section{C-language types}

In \hybridCOrCpp{}, all existing language types retain their current uses in
order to maximize compatibility, including \cintptrt, \cuintptrt, and
\maxalignt.
This is inconvenient with respect to capability pointer types, which cannot
be stored (without a downcast to an integer pointer type, losing capability
metadata) in \cintptrt.
A new type, \cintcapt, has been introduced, which is able to hold capability
pointer types -- but will be used only by source code that is capability
aware.

\section{Casts between integer and capability pointers}

\rwnote{This section onwards a work in progress.}

\subsection{Casts from integer to capability pointers}

Casts from integer pointers to capability pointers will silently \rwnote{is
this still true?} generate a capability pointer value derived from the
Default Data Capability (DDC).
As a result, they will generally have highly permissive bounds and
permissions, which should be refined for the capability to offer spatial,
and not just referential, protection.

For example, if an integer pointer to a heap allocation is to be exposed to
co-process IPC using a capability, the code performing a cast to a capability
pointer will typically also need to set bounds and permissions suitably.
This use case may also require stronger alignment for the heap allocation than
the existing heap allocator provides, as the allocator will be unaware of
capability bounds precision requirements.

Because of these risks, CHERI Clang/LLVM will always generate a warning in
the absense of use of the new \ccode{\_\_cheri\_addr} qualifier on the target
type of a cast.

\nwfnote{Recommend \ccode{cheri\_address\_set}?}

\subsection{Casts from capability to integer pointers}

Casts from capability pointers to integer pointers will take on a value that
is the integer difference between the address of the capability pointer and
the address of DDC.
These casts likewise discard capability metadata, preventing not only spatial
protection, but also referential protection.

Because of these risks, CHERI Clang/LLVM will always generate an error in
the absense of use of the new \ccode{\_\_cheri\_fromcap} qualifier on the
target type of a cast.

\section{\& operator}

The \ccode{\&} operator takes the address of a C or \cpp{} variable, and
returns a pointer of a corresponding type.
We consider three approaches:

\begin{description}
\item[Integer pointer interpretation] is the approach taken by CHERI
  Clang/LLVM.
  In this approach, \ccode{\&} returns an integer pointer type, the default
  pointer type in \hybridCOrCpp{}.
  If then assigned to a capability pointer, the resulting bounds and
  permissions are derived from the Default Data Capability (DDC).

\nwfnote{Does that mean that I can't write something like...  \ccode{struct \{
int x; int y; \} * \_\_capability sp; int * \_\_capability xp = \&sp->x;} and
have it work unless \ccode{sp} is a subset of DDC?  I'd sort of expect \& to be
polymorphic in its argument, even if it isn't polymorphic in its return type as
given next.}

\item[Polymorphic \ccode{\&}] \morellovariant{is the approach taken by Morello
  Clang/LLVM.
  In this approach, \ccode{\&} is polymorphic: if assigned to a capability
  pointer, the resulting bounds and permissions are those of the underlying
  type.}
  \rwnote{Or are they of the underlying storage?}

\item[Qualified \ccode{\&}]
  \futurevariant{This approach would qualify or modify the \ccode{\&} operator
  itself, perhaps in the form \ccode{\_\_capability \&}.
  This approach would avoid polymorphic behavior with the effect of the
  \ccode{\&} operator having different behavior based on otherts of a complex
  expression, or drawn from the type of the left-hand side of an assignment.
  Currently, no similar constructs to qualify or modify operators exist the C
  language.}
\end{description}

Another potential approach, avoided in our work to date, is to support a
silent downcast from a capability-pointer typed \ccode{\&} operator.
In general, we feel strongly that casts from capability-pointer types to
integer-pointer types should generate warnings (or even errors) due to the
potential for lost protection information and confusing outcomes.
In large existing corpora of \hybridCOrCpp{} code, large numbers of warnings
would be produced, and likely substantially distract from the goal of
producing safe code.

Regardless of the approach taken, it is important that the compiler warn if
there is a moderate likelihood that an assignment into a capability pointer
might contain default or too-broad bounds compared to the expectation of the
programmer.
Here, both the current CHERI Clang/LLVM and potential future CHERI Clang/LLVM
approaches require explicit warnings be generated, whereas the Morello
approach should avoid surprise at the cost of potentially problematic C
behavior.

\section{Limitations}

We consider two general sources of limitations, which are inevitably
intertwined:

\begin{itemize}
\item An uncomfortable programming model requiring manual annotation of
  source code
\item Incomplete referential, spatial, and temporal safety
\end{itemize}

\subsection{Programming model}

The \hybridCOrCpp{} programming model is a challenging one requiring
considerable care.
In general, it is our recommendation that the function of \hybridCOrCpp{} is
not improved memory safety, but rather interoperability with more
capability-centered \purecapCOrCpp{} across a fairly hard ABI boundary.
For example, the hybrid CheriBSD kernel variant implements its CheriABI
system-call layer in \hybridCOrCpp{} so that it can interact with capabilities
going to and from pure-capability user processes -- while itself primarily
relying on integer pointers internally.

In C code written to employ \ccode{typedef}s for pointer types, the level
of disruption associated with \uucap{} may not be enormous.
However, the useful setting of bounds is key.
In the use cases we imagine, such as kernel ABI interfaces and IPC libraries,
capabilities are used only in situtations in which suitable bounds and
permissions are natural products of the code implementing those services.
For example, if capabilities refer to a shared IPC memory object outside the
DDC-addressable memory of \hybridCOrCpp{} code, then the IPC library has
gained access to that capability from the party that allocated it in a
capability-aware way.
Similarly, hybrid kernels exchanging capabilities with user code will ensure
that suitable bounds are set of capabilities transmitted to userlevel, and
they will also return to the kernel with those bounds (or narrower ones)
intact.

Were more general-purpose programming the aim, a set of extended
capability-aware APIs (e.g., \ccode{malloc\_c()}, \ccode{mmap\_c()}, and so
on), returning and managing capability properties explicitly through
\uucap{}-extended types, would be required.

\subsection{Incomplete referential, spatial, and temporal safety}

This is a relatively weak integration of CHERI support with the language and
run-time environment offering limited memory protection only in very specific
circumstances.
Except where Application Programming Interfaces (APIs) have been extended to
support explicit capability arguments or return values, pointers will not
be protected by capability integrity, pointer provenance validity, bounds,
permissions, or monotonicity.
For example, \cfunc{malloc} will not return pointers as capabilities with
bounds set, and also may not align or pad allocations such that they can be
bounded imprecisely without loss of spatial protection relative to adjacent
allocations.
Further, the control-flow and other data structures used by C and the C
runtime themselves do not use capabilities, and so some of the resilience to
exploitation found in \purecapCOrCpp{}, such as return addresses and stack
pointers implemented using capabilities, are not found in \hybridCOrCpp{}.
Specific limitations by protection type are:

\begin{itemize}
\item Integer pointers, including those returned by default by various memory allocators, do
  not implement capability protections including tag, bounds, and permissions.
  As a result, integer pointers suffer from a lack of provenance validity and
  spatial safety.

\item Whenever a capability pointer type is cast to an integer pointer type,
  its capability metadata, including tag, bounds, and permissions, are lost.
  The resulting integer pointer will be dereferenced relative to the Default
  Data Capability (DDC), and uses those bounds and permissions, which may be
  substantial, and provenance validity is not implemented.

  \nwfnote{Casts to integers of tag-clear capabilities trap or succeed?}

\item Whenever an integer pointer type is cast to a capability pointer type,
  the compiler will derive the new capability from DDC without refining its
  bounds or permissions, offering provenance validity but not privilege
  minimization.

\item Both explicit function pointers and implied pointers such as return
  addresses and PLT entries are implemented as integer pointers, and therefore
  lack provenance validity, bounds, and permissions.
  Explicit capability pointers will have greater protection, but only subject
  to suitable setting of their metadata.

\item Other data structures implemented by the language runtime and compiler,
  such as the stack, are also implemented using integer pointers that do not
  implement provenance validity, bounds, or permissions.

\item CHERI temporal safety relies on capability implementation of pointers,
  so that the tag, bounds, and permissions can be utilized to detect stale
  pointers to quarantined memory.
  As many pointers in a hybrid program are implemented using integers,
  temporal safety is unable to precisely find all pointers or arrange for
  their suitably atomic replacement.
\end{itemize}

As a result of these limitations, privilege minimization in the language
runtime, control-flow mechanisms, and user data types is largely unimplementd.
Protections are only refined and enforced for programmer-selected types, which
can offer substantial value in specific scenarios, but is not a source of
general robustness for the C and \cpp implementations.
All privilege reductions are programmer-implemented through explicit calls to
narrow bounds and permissions.

\subsection{Origins of bounds and permissions}

Pointers implemented by capabilities by definition carry capability metadata:
tag, bounds, permissions, and so on.
In general, the \hybridCOrCpp{} runtime has much more limited information to
use as inputs for this metadata.
Where the address-of operator is used with a capability modifier, linkage
information (such as the captable) can be used as an origin of bounds for
global variables, and the stack allocator itself can provide bounds for local
variables.
Heap allocation requires API extensions that are not currently present (see
above).

\section{Further reading}
\label{sec:further_reading}

\rwnote{Update: The two real references are likely the CHERI C/C++ guide and
the Introduction to CHERI report}

The primary reference for the CHERI Instruction-Set Architecture (ISA) is the
ISA specification; at the time of writing, the most recent version is CHERI
ISAv7~\cite{UCAM-CL-TR-927}:

\smallskip
\noindent
\url{https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-927.pdf}
\smallskip

\noindent
Our technical report, \textit{An Introduction to CHERI}, provides a high-level
overview of the CHERI architecture, ISA modeling, hardware implementations,
and software stack~\cite{UCAM-CL-TR-941}:

\smallskip
\noindent
\url{https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-941.pdf}
\smallskip

\section{Acknowledgements}

\rwnote{Update feedback acknowledgments here.}

\rwnote{Add authors of CHERI C/C++ Programming Guide who don't end up being
  authors on this document.}

We gratefully acknowledge the helpful feedback from our colleagues, including
Ruben Ayrapetyan, Silviu Baranga, and Nathaniel Filardo.
This work was supported by the Defense Advanced Research Projects Agency (DARPA) and the Air Force Research Laboratory (AFRL), under contracts
FA8750-10-C-0237 (``CTSRD'') and HR0011-18-C-0016 (``ECATS'').
The views, opinions, and/or findings contained in this report are those of the authors and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.
This work was supported in part by the Innovate UK project Digital Security by
Design (DSbD) Technology Platform Prototype, 105694.
This project has received funding from the European Research Council
(ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement No 789108), ERC Advanced Grant ELVER.
We also acknowledge the EPSRC REMS Programme Grant (EP/K008528/1), Arm Limited,
HP Enterprise, and Google, Inc.
Approved for Public Release, Distribution Unlimited.

\printbibliography

\end{document}
